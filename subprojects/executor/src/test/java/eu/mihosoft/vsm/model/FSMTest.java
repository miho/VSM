/*
 * Copyright 2019-2021 Michael Hoffer <info@michaelhoffer.de>. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * If you use this software for scientific research then please cite the following publication(s):
 *
 * M. Hoffer, C. Poliwoda, & G. Wittum. (2013). Visual reflection library:
 * a framework for declarative GUI programming on the Java platform.
 * Computing and Visualization in Science, 2013, 16(4),
 * 181â€“192. http://doi.org/10.1007/s00791-014-0230-y
 */
/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package eu.mihosoft.vsm.model;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

import eu.mihosoft.vsm.executor.FSMExecutors;
import org.junit.Assert;
import org.junit.Test;

import java.lang.management.ManagementFactory;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class FSMTest {

    private static final AsyncFSMExecutor.ExecutionMode MODE
            = AsyncFSMExecutor.ExecutionMode.PARALLEL_REGIONS;

    private static final int NUM_ITERATIONS_LARGE_TESTS = 5;
    private static final int NUM_ITERATIONS_SMALL_TESTS = 10;

    static boolean sleepRandom(long min, long max) {
        long duration = ThreadLocalRandom.current().nextLong(max - min + 1) + min;
        try {
            Thread.sleep(duration);
            return true;
        } catch (InterruptedException e) {
            e.printStackTrace();
            return false;
        }
    }

    @Test
    public void testATMFSM() throws InterruptedException {

        for (int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            State idleState = State.newBuilder().withName("idle").withOnEntryAction(
                    (s, e) -> {
                        System.out.println("Machine Idle State");
                    }).build();

            State cardInserted = State.newBuilder().withName("cardInserted")
                    .withOnEntryAction((s, e) -> {
                        System.out.println("Card Inserted State");
                    }).build();

            State pinEnteredState = State.newBuilder().withName("pinEntered")
                    .withOnEntryAction((s, e) -> {
                        System.out.println("Pin Entered State");
                    }).build();

            State amountRequested = State.newBuilder().withName("amountRequested")
                    .withOnEntryAction((s, e) -> {
                        System.out.println("Amount Requested State");
                    }).build();

            Transition insertCardTransition = Transition.newBuilder().withTrigger("insert-card")
                    .withGuard((t, evt) -> {
                        if (evt.getArgs().isEmpty()) return false;
                        return Objects.equals("DE6594339437", evt.getArgs().get(0));
                    })
                    .withActions((s, e) -> {
                        System.out.println("-> correct card inserted");
                    }).withSource(idleState).withTarget(cardInserted).build();

            Transition enterPinTransition = Transition.newBuilder().withTrigger("enter-pin")
                    .withGuard((t, evt) -> {
                        System.out.println("-> pin entered");
                        System.out.println("-> checking...");

                        sleepRandom(0, 250);

                        if (evt.getArgs().isEmpty()) {
                            return false;
                        }

                        return Objects.equals(1234, evt.getArgs().get(0));
                    }).withActions((s, e) -> {
                        System.out.println("-> valid.");
                    }).withSource(cardInserted).withTarget(pinEnteredState).build();

            Transition requestAmountTransition = Transition.newBuilder().withTrigger("request-amount")
                    .withActions((s, e) -> {
                        System.out.println("-> amount-requested");
                    }).withSource(pinEnteredState).withTarget(amountRequested).build();

            Transition moneyDispatchedTransition = Transition.newBuilder().withTrigger("dispatch-money")
                    .withActions((s, e) -> {
                        System.out.println("-> checking whether requested amount is available");
                        sleepRandom(0, 80);
                        System.out.println("-> money-dispatched");
                    })
                    .withSource(amountRequested)
                    .withTarget(idleState)
                    .build();

            State errorState = State.newBuilder()
                    .withName("Error")
                    .withOnEntryAction((state, event) -> {
                        System.out.println("ERROR: ");
                    })
                    .build();

            FSM fsm = FSM.newBuilder()
                    .withName("ATM")
                    .withOwnedState(
                            idleState, cardInserted, pinEnteredState, amountRequested, errorState
                    )
                    .withInitialState(idleState)
                    .withErrorState(errorState)
                    .withTransitions(
                            insertCardTransition,
                            enterPinTransition,
                            requestAmountTransition,
                            moneyDispatchedTransition
                    )
                    .withVerbose(true)
                    .build();

            var visitedStates = Collections.synchronizedList(new ArrayList<State>());

            fsm.vmf().reflect().propertyByName("currentState").orElseThrow().addChangeListener(change -> {
                var oldV = (State) change.propertyChange().orElseThrow().oldValue();
                var newV = (State) change.propertyChange().orElseThrow().newValue();
                System.out.println(Thread.currentThread() + " > transitioned from " +
                        (oldV == null ? "<undefined>" : oldV.getName()) +
                        " to " +
                        (newV == null ? "<undefined>" : newV.getName()));
                if (newV != null) {
                    visitedStates.add(newV);
                }
            });

            var executor = FSMExecutors.newAsyncExecutor(fsm, MODE);

            executor.startAsync();

            sleepRandom(0, 2500);

            executor.trigger("insert-card", "DE6594339437");

            sleepRandom(0, 250);

            executor.trigger("enter-pin", 1234);

            sleepRandom(0, 350);

            executor.trigger("request-amount", 35);

            var f = new CompletableFuture();
            executor.trigger("dispatch-money", (e, t) -> {
                f.complete(null);
            }, 35);

            // wait until last event is consumed
            f.orTimeout(10000, TimeUnit.MILLISECONDS).join();

            executor.stop();

            System.out.println("> Visited States: "
                    + visitedStates.stream().map(s -> s.getName()).
                    collect(Collectors.joining(", "))
            );

            System.out.println("> number of active threads: " + ManagementFactory.getThreadMXBean().getThreadCount());

            assertThat(visitedStates, contains(
                            idleState,
                            cardInserted,
                            pinEnteredState,
                            amountRequested,
                            idleState
                    )
            );

        }

    }

    @Test
    public void nestedOrthogonalWithDoActionProcessingTest() throws InterruptedException {

        for (int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            System.out.println("-------------- nestedOrthogonalWithDoActionProcessingTest(), iteration: " + i);

            var actualEvtList = new ArrayList<String>();

            FSM fsm = createNestedWithOrthogonal(actualEvtList, false);

            var executor = FSMExecutors.newAsyncExecutor(fsm, MODE);
//        executor.startAsync();
            fsm.setRunning(true);
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            //executor.process("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));

            while (executor.hasRemainingEvents()) {
                executor.processRemainingEvents();
            }

            if (MODE == AsyncFSMExecutor.ExecutionMode.PARALLEL_REGIONS) {

                Thread.sleep(100); // TODO (hasRemainingEvents() might still be buggy)

                while (executor.hasRemainingEvents()) {
                    executor.processRemainingEvents();
                }
            }


            fsm.setRunning(false);

            var expectedEvtList = Arrays.asList(
                    "enter state a",               // <- fsm:init
                    "exit state a",                // <- myEvent 1
                    "enter state b",               //
                    "exit state b",                // <- myEvent 2
                    "enter state c",               //
//                "enter do-action-in-state-c",  // test without enter do-action-in-state-c, because position may vary
                    "enter state ca1",             //
                    "enter state ca2",             //
                    "exit state ca2",              // <- myEvent 2
                    "enter state cb2",             //
                    "exit state cb2",              // (fsm reached final state)
                    "exit state ca1",              // <- myEvent 1
                    "enter state cb1",             //
                    "exit state cb1",              // (fsm reached final state)
                    "exit do-action-in-state-c",   // <- timeout (sleep)
                    "exit state c",                //
                    "enter state a"                //
            );

            // test without enter do-action-in-state-c, because position may vary
            actualEvtList.remove("enter do-action-in-state-c");

            // A better way to verify correct execution is to trace child FSMs aka regions individually.
            // But in this configuration we cannot test for a specific sequence.
            Assert.assertEquals(expectedEvtList.size(), actualEvtList.size());
        }
    }

    @Test
    public void nestedOrthogonalWithDoActionInterruptedProcessingTest() {

        for (int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            var actualEvtList = new ArrayList<String>();

            FSM fsm = createNestedWithOrthogonal(actualEvtList, false);

            var executor = FSMExecutors.newAsyncExecutor(fsm, MODE);

            fsm.setRunning(true);
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));

            while (executor.hasRemainingEvents()) {
                executor.processRemainingEvents();
            }

            fsm.setRunning(false);

            var expectedEvtList = Arrays.asList(
                    "enter state a",                   // <- fsm:init
                    "exit state a",                    // <- myEvent 1
                    "enter state b",                   //
                    "exit state b",                    // <- myEvent 2
                    "enter state c",                   //
//                "enter do-action-in-state-c",      // test without enter do-action-in-state-c, because position may vary
                    "enter state ca1",                 //
                    "enter state ca2",                 //
                    "exit state ca2",                  // <- myEvent 2
                    "enter state cb2",                 //
                    "exit state cb2",                  // (fsm reached final state)
                    "exit state ca1",                  // <- myEvent 1
                    "enter state cb1",                 //
                    "exit state cb1",                  // (fsm reached final state)
                    "interrupt do-action-in-state-c",  // <- myEvent 1
                    "exit do-action-in-state-c",       //
                    "exit state c",                    //
                    "enter state a"                    //
            );

            // test without enter do-action-in-state-c, because position may vary
            actualEvtList.remove("enter do-action-in-state-c");

            // A better way to verify correct execution is to trace child FSMs aka regions individually.
            // But in this configuration we cannot test for a specific sequence.
            Assert.assertEquals(expectedEvtList.size(), actualEvtList.size());
        }
    }

    @Test
    public void nestedOrthogonalWithDoActionAsyncTest() throws InterruptedException {

        for (int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            var actualEvtList = new ArrayList<String>();

            FSM fsm = createNestedWithOrthogonal(actualEvtList, false);

            var executor = FSMExecutors.newAsyncExecutor(fsm, MODE);
            executor.startAsync();

            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            //executor.process("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));

            Thread.sleep(1500);

            executor.stop();

            var expectedEvtList = Arrays.asList(
                    "enter state a",               // <- fsm:init
                    "exit state a",                // <- myEvent 1
                    "enter state b",               //
                    "exit state b",                // <- myEvent 2
                    "enter state c",               //
//                "enter do-action-in-state-c",  // test without enter do-action-in-state-c, because position may vary
                    "enter state ca1",             //
                    "enter state ca2",             //
                    "exit state ca2",              // <- myEvent 2
                    "enter state cb2",             //
                    "exit state cb2",              // (fsm reached final state)
                    "exit state ca1",              // <- myEvent 1
                    "enter state cb1",             //
                    "exit state cb1",              // (fsm reached final state)
                    "exit do-action-in-state-c",   // <- timeout (sleep)
                    "exit state c",                //
                    "enter state a"                //
            );

            // test without enter do-action-in-state-c, because position may vary
            actualEvtList.remove("enter do-action-in-state-c");

            System.out.println("---------------------------------");
            System.out.println(actualEvtList);

            // A better way to verify correct execution is to trace child FSMs aka regions individually.
            // But in this configuration we cannot test for a specific sequence.
            Assert.assertEquals(expectedEvtList.size(), actualEvtList.size());
        }
    }

    @Test
    public void nestedOrthogonalWithDoActionInterruptAsyncTest() throws InterruptedException {

        for (int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            var actualEvtList = new ArrayList<String>();

            FSM fsm = createNestedWithOrthogonal(actualEvtList, false);

            var executor = FSMExecutors.newAsyncExecutor(fsm, MODE);
            executor.startAsync();

            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));


            Thread.sleep(200);
            executor.stop();

            var expectedEvtList = Arrays.asList(
                    "enter state a",                   // <- fsm:init
                    "exit state a",                    // <- myEvent 1
                    "enter state b",                   //
                    "exit state b",                    // <- myEvent 2
                    "enter state c",                   //
//                "enter do-action-in-state-c",      // test without enter do-action-in-state-c, because position may vary
                    "enter state ca1",                 //
                    "enter state ca2",                 //
                    "exit state ca2",                  // <- myEvent 2
                    "enter state cb2",                 //
                    "exit state cb2",                  // (fsm reached final state)
                    "exit state ca1",                  // <- myEvent 1
                    "enter state cb1",                 //
                    "exit state cb1",                  // (fsm reached final state)
                    "interrupt do-action-in-state-c",  // <- myEvent 1
                    "exit do-action-in-state-c",       //
                    "exit state c",                    //
                    "enter state a"                    //
            );

            // test without enter do-action-in-state-c, because position may vary
            actualEvtList.remove("enter do-action-in-state-c");

            // A better way to verify correct execution is to trace child FSMs aka regions individually.
            // But in this configuration we cannot test for a specific sequence.
            Assert.assertEquals(expectedEvtList.size(), actualEvtList.size());
        }
    }

    @Test
    public void nestedOrthogonalWithDoActionInterruptViaFinalStateAsyncTest() throws InterruptedException {

        // if 'final-state' from nested is emitted, we can interrupt the do-action if we define a
        // transition with trigger 'final-state'

        for (int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            var actualEvtList = new ArrayList<String>();

            FSM fsm = createNestedWithOrthogonal(actualEvtList, true);

            var executor = FSMExecutors.newAsyncExecutor(fsm, MODE);
            executor.startAsync();

            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));

            Thread.sleep(200);
            executor.stop();

            var expectedEvtList = Arrays.asList(
                    "enter state a",                   // <- fsm:init
                    "exit state a",                    // <- myEvent 1
                    "enter state b",                   //
                    "exit state b",                    // <- myEvent 2
                    "enter state c",                   //
//                "enter do-action-in-state-c",      // test without enter do-action-in-state-c, because position may vary
                    "enter state ca1",                 //
                    "enter state ca2",                 //
                    "exit state ca2",                  // <- myEvent 2
                    "enter state cb2",                 //
                    "exit state cb2",                  // (fsm reached final state)
                    "exit state ca1",                  // <- myEvent 1
                    "enter state cb1",                 //
                    "exit state cb1",                  // (fsm reached final state)
                    "interrupt do-action-in-state-c",  // <- myEvent 1
                    "exit do-action-in-state-c",       //
                    "exit state c",                    //
                    "enter state a"                    //
            );

            // test without enter do-action-in-state-c, because position may vary
            actualEvtList.remove("enter do-action-in-state-c");

            // A better way to verify correct execution is to trace child FSMs aka regions individually.
            // But in this configuration we cannot test for a specific sequence.
            Assert.assertEquals(expectedEvtList.size(), actualEvtList.size());
        }
    }

    private static FSM createNestedWithOrthogonal(List<String> enterExitListOrig, boolean finalStateInNested) {

        //        +------+             +----------------------+
        //        |      |    EV1      | C |               R1 |
        //        |  A   |<------------|---/                  |
        //        |      |    or       | +----+  EV1  +----+  |
        //        |      | final-state | | CA |------>| CB |  | <--- CB is final state
        //        +------+             | +----+       +----+  |
        //           |                 |                      |
        //           | EV1             |--------------------->|
        //           |                 |                   R2 |
        //           v                 |                      |
        //        +------+             | +----+  EV1  +----+  |
        //        |      |     EV2     | | CA |------>| CB |  | <--- CB is final state
        //        |  B   |------------>| +----+       +----+  |
        //        |      |             |                      |
        //        +------+             +----------------------+

        final var enterExitList = Collections.synchronizedList(enterExitListOrig);

        State stateA = State.newBuilder()
                .withName("State A")
                .withOnEntryAction((s, e) -> {
                    System.out.println("enter state a");
                    enterExitList.add("enter state a");
                })
//                .withDoAction()
                .withOnExitAction((s, e) -> {
                    System.out.println("exit state a");
                    enterExitList.add("exit state a");
                })
                .build();
        State stateB = State.newBuilder()
                .withName("State B")
                .withOnEntryAction((s, e) -> {
                    System.out.println("enter state b");
                    enterExitList.add("enter state b");
                })
//                .withDoAction()
                .withOnExitAction((s, e) -> {
                    System.out.println("exit state b");
                    enterExitList.add("exit state b");
                })
                .build();

        State stateCA1 = State.newBuilder()
                .withName("State CA1")
                .withOnEntryAction((s, e) -> {
                    System.out.println("  enter state ca1");
                    enterExitList.add("enter state ca1");
                })
//                .withDoAction()
                .withOnExitAction((s, e) -> {
                    System.out.println("  exit state ca1");
                    enterExitList.add("exit state ca1");
                })
                .build();

        State stateCB1 = State.newBuilder()
                .withName("State CB1")
                .withOnEntryAction((s, e) -> {
                    System.out.println("  enter state cb1");
                    enterExitList.add("enter state cb1");
                })
//                .withDoAction()
                .withOnExitAction((s, e) -> {
                    System.out.println("  exit state cb1");
                    enterExitList.add("exit state cb1");
                })
                .build();

        State stateCA2 = State.newBuilder()
                .withName("State CA2")
                .withOnEntryAction((s, e) -> {
                    System.out.println("  enter state ca2");
                    enterExitList.add("enter state ca2");
                })
//                .withDoAction()
                .withOnExitAction((s, e) -> {
                    System.out.println("  exit state ca2");
                    enterExitList.add("exit state ca2");
                })
                .build();

        State stateCB2 = State.newBuilder()
                .withName("State CB2")
                .withOnEntryAction((s, e) -> {
                    System.out.println("  enter state cb2");
                    enterExitList.add("enter state cb2");
                })
//                .withDoAction()
                .withOnExitAction((s, e) -> {
                    System.out.println("  exit state cb2");
                    enterExitList.add("exit state cb2");
                })
                .build();


        FSMState stateC = FSMState.newBuilder()
                .withName("State C")
                .withOnEntryAction((s, e) -> {
                    System.out.println("enter state c");
                    enterExitList.add("enter state c");
                })
                .withOnExitAction((s, e) -> {
                    System.out.println("exit state c");
                    enterExitList.add("exit state c");
                })
                .withDoAction((s, e) -> {
                    try {
                        System.out.println("enter do-action-in-state-c");
                        enterExitList.add("enter do-action-in-state-c");
                        Thread.sleep(1000);
                    } catch (InterruptedException interruptedException) {
                        System.out.println("interrupt do-action-in-state-c");
                        enterExitList.add("interrupt do-action-in-state-c");
                        Thread.currentThread().interrupt();
                    } finally {
                        System.out.println("exit do-action-in-state-c");
                        enterExitList.add("exit do-action-in-state-c");
                    }
                })
                .withFSMs(
                        FSM.newBuilder()
                                .withName("FSM C1")
//                                .withVerbose(true)
                                .withOwnedState(stateCA1, stateCB1)
                                .withInitialState(stateCA1)
                                .withFinalState(stateCB1)
                                .withTransitions(
                                        Transition.newBuilder()
                                                .withSource(stateCA1)
                                                .withTarget(stateCB1)
                                                .withTrigger("myEvent1")
                                                .build()
                                )
                                .build(),
                        FSM.newBuilder()
                                .withName("FSM C2")
//                                .withVerbose(true)
                                .withOwnedState(stateCA2, stateCB2)
                                .withInitialState(stateCA2)
                                .withFinalState(stateCB2)
                                .withTransitions(
                                        Transition.newBuilder()
                                                .withSource(stateCA2)
                                                .withTarget(stateCB2)
                                                .withTrigger("myEvent2")
                                                .build()
                                )
                                .build()
                )
                .build();

        FSM fsm = FSM.newBuilder()
                .withName("FSM")
                .withVerbose(true)
                .withInitialState(stateA)
                .withOwnedState(stateA, stateB, stateC)
                .withTransitions(
                        Transition.newBuilder()
                                .withSource(stateA)
                                .withTarget(stateB)
                                .withTrigger("myEvent1")
                                .build(),
                        Transition.newBuilder()
                                .withSource(stateB)
                                .withTarget(stateC)
                                .withTrigger("myEvent2")
                                .build(),
                        Transition.newBuilder()
                                .withSource(stateC)
                                .withTarget(stateA)
                                .withTrigger("myEvent1")
                                .build()
                        ,
                        Transition.newBuilder()
                                .withSource(stateC)
                                .withTarget(stateA)
                                .withTrigger(finalStateInNested
                                        ? FSMExecutor.FSMEvents.FINAL_STATE.getName()
                                        : FSMExecutor.FSMEvents.DO_ACTION_DONE.getName())
                                .build()
                )
                .build();

        return fsm;
    }

    @Test(timeout = 500_000)
    public void enterNestedStateDirectlyTest() throws InterruptedException {

        for (int i = 0; i < NUM_ITERATIONS_SMALL_TESTS; i++) {

            var actualEvtList = new ArrayList<String>();

            FSM fsm_a = FSM.newBuilder()
                    .withName("FSM a")
                    .withVerbose(true)
                    .build();

            FSM fsm_a_a = FSM.newBuilder()
                    .withName("FSM a_a")
                    .withVerbose(true)
                    .build();

            FSM fsm_a_b = FSM.newBuilder()
                    .withName("FSM a_b")
                    .withVerbose(true)
                    .build();

            State state_a = FSMState.newBuilder()
                    .withName("a")
                    .withOnEntryAction((s, e) -> {
                        actualEvtList.add("enter state a");
                        System.out.println("enter state a");
                    })
                    .withOnExitAction((s, e) -> {
                        actualEvtList.add("exit state a");
                        System.out.println("exit state a");
                    })
                    .withFSMs(fsm_a)
                    .build();

            State state_a_a = FSMState.newBuilder()
                    .withName("a_a")
                    .withOnEntryAction((s, e) -> {
                        actualEvtList.add("enter state a_a");
                        System.out.println("enter state a_a");
                    })
                    .withOnExitAction((s, e) -> {
                        actualEvtList.add("exit state a_a");
                        System.out.println("exit state a_a");
                    })
                    .withFSMs(fsm_a_a)
                    .build();

            State state_a_a_a = State.newBuilder()
                    .withName("a_a_a")
                    .withOnEntryAction((s, e) -> {
                        actualEvtList.add("enter state a_a_a");
                        System.out.println("enter state a_a_a");
                    })
                    .withOnExitAction((s, e) -> {
                        actualEvtList.add("exit state a_a_a");
                        System.out.println("exit state a_a_a");
                    })
                    .build();

            State state_a_b = FSMState.newBuilder()
                    .withName("a_b")
                    .withOnEntryAction((s, e) -> {
                        actualEvtList.add("enter state a_b");
                        System.out.println("enter state a_b");
                    })
                    .withOnExitAction((s, e) -> {
                        actualEvtList.add("exit state a_b");
                        System.out.println("exit state a_b");
                    })
                    .withFSMs(fsm_a_b)
                    .build();

            fsm_a.getOwnedState().add(state_a_a);
            fsm_a.getOwnedState().add(state_a_b);
            fsm_a.setInitialState(state_a_a);

            fsm_a_a.getOwnedState().add(state_a_a_a);
            fsm_a_a.setInitialState(state_a_a_a);

            State state_a_b_a = State.newBuilder()
                    .withName("a_b_a")
                    .withOnEntryAction((s, e) -> {
                        actualEvtList.add("enter state a_b_a");
                        System.out.println("enter state a_b_a");
                    })
                    .withOnExitAction((s, e) -> {
                        actualEvtList.add("exit state a_b_a");
                        System.out.println("exit state a_b_a");
                    })
                    .build();

            Transition a_a_a__a_b_a = Transition.newBuilder()
                    .withTrigger("myEvent1")
                    .withSource(state_a_a_a)
                    .withTarget(state_a_b_a)
                    .build();

            fsm_a_b.getOwnedState().add(state_a_b_a);
            fsm_a_b.setInitialState(state_a_b_a);

            FSM fsm = FSM.newBuilder()
                    .withOwnedState(state_a)
                    .withInitialState(state_a)
                    .withVerbose(true)
                    .build();

            fsm_a.getTransitions().add(a_a_a__a_b_a);

            var executor = FSMExecutors.newAsyncExecutor(fsm, MODE);
//            fsm.setRunning(true);
            var f = executor.startAsync();
            Thread.sleep(1000);
            executor.trigger("myEvent1");
            Thread.sleep(1000);

            var expectedEvtList = Arrays.asList(
                    "enter state a",                    // <- fsm:init
                    "enter state a_a",                  //
                    "enter state a_a_a",                //
                    "exit state a_a_a",                 // <- myEvent1
                    "exit state a_a",                   //
                    "enter state a_b",                  //
                    "enter state a_b_a"                 //
            );

            Assert.assertEquals(expectedEvtList, actualEvtList);

        } // end for i

    }

    @Test
    public void lockedDoorTest() throws InterruptedException {

        var actualEvtList = new ArrayList<String>();

        String event_close = "close";
        String event_open = "open";
        String event_lock = "lock";
        String event_unlock = "unlock";

        State opened = State.newBuilder()
                .withName("opened")
                .withOnEntryAction((s, e) -> {
                    actualEvtList.add("enter opened");
                })
                .withOnExitAction((s, e) -> actualEvtList.add("exit opened"))
                .build();

        State closed = State.newBuilder()
                .withName("closed")
                .withOnEntryAction((s, e) -> actualEvtList.add("enter closed"))
                .withOnExitAction((s, e) -> actualEvtList.add("exit closed"))
                .build();

        State locked = State.newBuilder()
                .withName("locked")
                .withOnEntryAction((s, e) -> actualEvtList.add("enter locked"))
                .withOnExitAction((s, e) -> actualEvtList.add("exit locked"))
                .build();


        Transition closeDoor = Transition.newBuilder()
                .withTrigger(event_close)
                .withSource(opened)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("closeDoor(), evt: " + e.getName());
                    actualEvtList.add("closeDoor()");
                })
                .build();

        Transition openDoor = Transition.newBuilder()
                .withTrigger(event_open)
                .withSource(closed)
                .withTarget(opened)
                .withActions((t, e) -> {
                    System.out.println("openDoor(), evt: " + e.getName());
                    actualEvtList.add("openDoor()");
                })
                .build();

        Transition lockDoor = Transition.newBuilder()
                .withTrigger(event_lock)
                .withSource(closed)
                .withTarget(locked)
                .withActions((t, e) -> {
                    System.out.println("lockDoor(), evt: " + e.getName());
                    actualEvtList.add("lockDoor()");
                })
                .build();

        Transition unlockDoor = Transition.newBuilder()
                .withTrigger(event_unlock)
                .withSource(locked)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("unlockDoor(), evt: " + e.getName());
                    actualEvtList.add("unlockDoor()");
                })
                .build();

        FSM fsm = FSM.newBuilder()
                .withInitialState(opened)
                .withOwnedState(opened, closed, locked)
                .withTransitions(openDoor, closeDoor, lockDoor, unlockDoor)
                .build();

        var executor = FSMExecutors.newAsyncExecutor(fsm, MODE);

        fsm.setRunning(true);

        executor.process(event_close);
        executor.process(event_lock);
        executor.process(event_unlock);
        executor.process(event_open);

        executor.process(event_lock); // try invalid
        executor.process(event_close);
        executor.process(event_lock);

        executor.process(event_open); // try invalid

        fsm.setRunning(false);

        var expectedEvtList = Arrays.asList(
                "enter opened",  // <- fsm:init

                "exit opened",
                "closeDoor()",
                "enter closed",

                "exit closed",
                "lockDoor()",
                "enter locked",

                "exit locked",
                "unlockDoor()",
                "enter closed",

                "exit closed",
                "openDoor()",
                "enter opened",

                // not "lockDoor()" because it's invalid

                "exit opened",
                "closeDoor()",
                "enter closed",

                "exit closed",
                "lockDoor()",
                "enter locked"

                // not "openDoor()" because it's invalid
        );

        Assert.assertEquals(expectedEvtList, actualEvtList);

    }

    @Test
    public void lockedDoorWithLockVariableAndLocalTransitionTest() throws InterruptedException {

        var actualEvtList = new ArrayList<String>();

        String event_close = "close";
        String event_open = "open";
        String event_lock = "lock";
        String event_unlock = "unlock";

        AtomicBoolean lockedState = new AtomicBoolean();

        State opened = State.newBuilder()
                .withName("opened")
                .withOnEntryAction((s, e) -> {
                    actualEvtList.add("enter opened");
                })
                .withOnExitAction((s, e) -> actualEvtList.add("exit opened"))
                .build();

        State closed = State.newBuilder()
                .withName("closed")
                .withOnEntryAction((s, e) -> actualEvtList.add("enter closed"))
                .withOnExitAction((s, e) -> actualEvtList.add("exit closed"))
                .build();


        Transition closeDoor = Transition.newBuilder()
                .withTrigger(event_close)
                .withSource(opened)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("closeDoor(), evt: " + e.getName());
                    actualEvtList.add("closeDoor()");
                })
                .build();

        Transition openDoor = Transition.newBuilder()
                .withTrigger(event_open)
                .withSource(closed)
                .withTarget(opened)
                .withGuard((transition, event) -> !lockedState.get())
                .withActions((t, e) -> {
                    System.out.println("openDoor(), evt: " + e.getName());
                    actualEvtList.add("openDoor()");
                })
                .build();

        Transition lockDoor = Transition.newBuilder()
                .withLocal(true)
                .withTrigger(event_lock)
                .withSource(closed)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("lockDoor(), evt: " + e.getName());
                    actualEvtList.add("lockDoor()");
                    lockedState.set(true);
                })
                .build();

        Transition unlockDoor = Transition.newBuilder()
                .withLocal(true)
                .withTrigger(event_unlock)
                .withSource(closed)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("unlockDoor(), evt: " + e.getName());
                    actualEvtList.add("unlockDoor()");
                    lockedState.set(false);
                })
                .build();

        FSM fsm = FSM.newBuilder()
                .withInitialState(opened)
                .withOwnedState(opened, closed)
                .withTransitions(openDoor, closeDoor, lockDoor, unlockDoor)
                .build();

        var executor = FSMExecutors.newAsyncExecutor(fsm, MODE);

        fsm.setRunning(true);

        executor.process(event_close);
        executor.process(event_lock);
        executor.process(event_unlock);
        executor.process(event_open);

        executor.process(event_lock); // try invalid
        executor.process(event_close);
        executor.process(event_lock);

        executor.process(event_open); // try invalid

        fsm.setRunning(false);

        var expectedEvtList = Arrays.asList(
                "enter opened",  // <- fsm:init

                "exit opened",
                "closeDoor()",
                "enter closed",

//                "exit closed",  // self, deactivated due to local transitions (no enter and exit)
                "lockDoor()",
//                "enter closed", // self, deactivated due to local transitions (no enter and exit)


//                "exit closed",  // self, deactivated due to local transitions (no enter and exit)
                "unlockDoor()",
//                "enter closed", // self, deactivated due to local transitions (no enter and exit)

                "exit closed",
                "openDoor()",
                "enter opened",

                // not "lockDoor()" because it's invalid

                "exit opened",
                "closeDoor()",
                "enter closed",

//                "exit closed"   // self, deactivated due to local transitions (no enter and exit)
                "lockDoor()"
//                "enter closed"  // self, deactivated due to local transitions (no enter and exit)

                // not "openDoor()" because it's invalid
        );

        Assert.assertEquals(expectedEvtList, actualEvtList);

    }

    @Test
    public void lockedDoorWithLockVariableTest() throws InterruptedException {

        var actualEvtList = new ArrayList<String>();

        String event_close = "close";
        String event_open = "open";
        String event_lock = "lock";
        String event_unlock = "unlock";

        AtomicBoolean lockedState = new AtomicBoolean();

        State opened = State.newBuilder()
                .withName("opened")
                .withOnEntryAction((s, e) -> {
                    actualEvtList.add("enter opened");
                })
                .withOnExitAction((s, e) -> actualEvtList.add("exit opened"))
                .build();

        State closed = State.newBuilder()
                .withName("closed")
                .withOnEntryAction((s, e) -> actualEvtList.add("enter closed"))
                .withOnExitAction((s, e) -> actualEvtList.add("exit closed"))
                .build();


        Transition closeDoor = Transition.newBuilder()
                .withTrigger(event_close)
                .withSource(opened)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("closeDoor(), evt: " + e.getName());
                    actualEvtList.add("closeDoor()");
                })
                .build();

        Transition openDoor = Transition.newBuilder()
                .withTrigger(event_open)
                .withSource(closed)
                .withTarget(opened)
                .withGuard((transition, event) -> !lockedState.get())
                .withActions((t, e) -> {
                    System.out.println("openDoor(), evt: " + e.getName());
                    actualEvtList.add("openDoor()");
                })
                .build();

        Transition lockDoor = Transition.newBuilder()
                .withTrigger(event_lock)
                .withSource(closed)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("lockDoor(), evt: " + e.getName());
                    actualEvtList.add("lockDoor()");
                    lockedState.set(true);
                })
                .build();

        Transition unlockDoor = Transition.newBuilder()
                .withTrigger(event_unlock)
                .withSource(closed)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("unlockDoor(), evt: " + e.getName());
                    actualEvtList.add("unlockDoor()");
                    lockedState.set(false);
                })
                .build();

        FSM fsm = FSM.newBuilder()
                .withInitialState(opened)
                .withOwnedState(opened, closed)
                .withTransitions(openDoor, closeDoor, lockDoor, unlockDoor)
                .build();

        var executor = FSMExecutors.newAsyncExecutor(fsm, MODE);

        fsm.setRunning(true);

        executor.process(event_close);
        executor.process(event_lock);
        executor.process(event_unlock);
        executor.process(event_open);

        executor.process(event_lock); // try invalid
        executor.process(event_close);
        executor.process(event_lock);

        executor.process(event_open); // try invalid

        fsm.setRunning(false);

        var expectedEvtList = Arrays.asList(
                "enter opened",  // <- fsm:init

                "exit opened",
                "closeDoor()",
                "enter closed",

                "exit closed",   // self
                "lockDoor()",
                "enter closed",  // self


                "exit closed",   // self
                "unlockDoor()",
                "enter closed",  // self

                "exit closed",
                "openDoor()",
                "enter opened",

                // not "lockDoor()" because it's invalid

                "exit opened",
                "closeDoor()",
                "enter closed",

                "exit closed",   // self
                "lockDoor()",
                "enter closed"   // self

                // not "openDoor()" because it's invalid
        );

        Assert.assertEquals(expectedEvtList, actualEvtList);

    }

//    @Test
//    public void localVsExternalTransitionTest() {
//        var actualEvtList = new ArrayList<String>();
//
//        StateAction entryAction = (s, e) -> {
//            actualEvtList.add("enter " + s.getName());
//        };
//
//        StateAction exitAction = (s, e) -> {
//            actualEvtList.add("exit " + s.getName());
//        };
//
//        State childState1 = State.newBuilder()
//                .withName("Child1")
//                .withOnEntryAction(entryAction)
//                .withOnExitAction(exitAction)
//                .build();
//
//        State childState2 = State.newBuilder()
//                .withName("Child2")
//                .withOnEntryAction(entryAction)
//                .withOnExitAction(exitAction)
//                .build();
//
//        State parentState = FSMState.newBuilder()
//                .withName("Parent")
//                .withOnEntryAction(entryAction)
//                .withOnExitAction(exitAction)
//                .withFSMs(FSM.newBuilder().withName("Nested FSM")
//                        .withInitialState(childState1)
//                        .withOwnedState(childState1, childState2)
//                        .build())
//                .build();
//
//        Transition t = Transition.newBuilder()
//                .withTrigger("event")
//                .withSource(parentState)
//                .withTarget(childState2)
//                .build();
//
//        FSM fsm = FSM.newBuilder()
//                .withInitialState(parentState)
//                .withOwnedState(parentState)
//                .withTransitions(t)
//                .build();
//
//        Executor executor = Executor.newInstance(fsm, MODE);
//
//        fsm.setRunning(true);
//        executor.process("event");
//        fsm.setRunning(false);
//
//        System.out.println(actualEvtList);
//
//        actualEvtList.clear();
//
//        t.setLocal(true);
//        fsm.setRunning(true);
//        executor.reset();
//        executor.process("event");
//        fsm.setRunning(false);
//
//        System.out.println(actualEvtList);
//
//    }

    @Test
    public void transitionPriorityTest1() throws InterruptedException, ExecutionException {

        for (int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            System.out.println("# ITERATIONS: " + i);

            {
                System.out.println("\nCase Priority to C2:");
                List<String> actualEvtList = new ArrayList<>();
                FSM fsm = createTransitionPriorityFSM(actualEvtList, true);
                var executor = FSMExecutors.newAsyncExecutor(fsm, MODE);

                executor.startAsync();

                System.out.println("----> triggering event 1");
                executor.trigger("event1");
                System.out.println("----> triggering event 2");
                executor.trigger("event2");

                Thread.sleep(50);
                executor.stop();

                System.out.println("\nPriority to C2, FSM reactions: ");
                System.out.println(String.join("\n", actualEvtList));

                var expectedEvtList = Arrays.asList(
                        "enter s1",      // <- fsm:init

                        "exit s1",       // <- event1
                        "transitioning from s1 to parent, via event event1",
                        "enter parent",
                        "enter c1",

                        "exit c1",       // <- event2
                        "exit parent",
                        "transitioning from parent to c2, via event event2",
                        "enter parent",
                        "enter c2"
                );

                Assert.assertEquals(expectedEvtList, actualEvtList);
            }

            {
                System.out.println("\nCase Priority to S2:");
                List<String> actualEvtList = new ArrayList<>();
                FSM fsm = createTransitionPriorityFSM(actualEvtList, false);
                var executor = FSMExecutors.newAsyncExecutor(fsm, MODE);

                executor.startAsync();

                System.out.println("----> triggering event 1");
                executor.trigger("event1");
                System.out.println("----> triggering event 2");
                executor.trigger("event2");

                Thread.sleep(50);
                executor.stop();

                System.out.println("\nFSM reactions: ");
                System.out.println(String.join("\n", actualEvtList));

                var expectedEvtList = Arrays.asList(
                        "enter s1",      // <- fsm:init

                        "exit s1",       // <- event1
                        "transitioning from s1 to parent, via event event1",
                        "enter parent",
                        "enter c1",

                        "exit c1",       // <- event2
                        "exit parent",
                        "transitioning from parent to s2, via event event2",
                        "enter s2"
                );

                Assert.assertEquals(expectedEvtList, actualEvtList);
            }

        } // end for i

    }

    private FSM createTransitionPriorityFSM(List<String> actualEvtListOrig, boolean parent_c2_first) {
        var actualEvtList = Collections.synchronizedList(actualEvtListOrig);

        StateAction entryAction = (s, e) -> {
            actualEvtList.add("enter " + s.getName());
        };

        StateAction exitAction = (s, e) -> {
            actualEvtList.add("exit " + s.getName());
        };

        TransitionAction transitioned = (t, e) -> {
            actualEvtList.add("transitioning from " + t.getSource().getName()
                    + " to " + t.getTarget().getName() + ", via event " + e.getName());
        };

        State c1 = State.newBuilder()
                .withName("c1")
                .withOnEntryAction(entryAction)
                .withOnExitAction(exitAction)
                .build();

        State c2 = State.newBuilder()
                .withName("c2")
                .withOnEntryAction(entryAction)
                .withOnExitAction(exitAction)
                .build();

        Transition c1_c2 = Transition.newBuilder()
                .withTrigger("event1")
                .withSource(c1)
                .withTarget(c2)
                .withActions(transitioned)
                .build();

        FSMState parent = FSMState.newBuilder()
                .withName("parent")
                .withOnEntryAction(entryAction)
                .withOnExitAction(exitAction)
                .withFSMs(FSM.newBuilder()
                        .withName("parent:r1")
                        .withOwnedState(c1, c2)
                        .withInitialState(c1)
                        .withTransitions(c1_c2)
                        .build()
                )
                .build();

        State s1 = State.newBuilder()
                .withName("s1")
                .withOnEntryAction(entryAction)
                .withOnExitAction(exitAction)
                .build();

        State s2 = State.newBuilder()
                .withName("s2")
                .withOnEntryAction(entryAction)
                .withOnExitAction(exitAction)
                .build();

        Transition s1_parent = Transition.newBuilder()
                .withSource(s1)
                .withTarget(parent)
                .withTrigger("event1")
                .withActions(transitioned)
                .build();

        Transition parent_s2 = Transition.newBuilder()
                .withSource(parent)
                .withTarget(s2)
                .withTrigger("event1")
                .withActions(transitioned)
                .build();

        Transition parent_c2 = Transition.newBuilder()
                .withTrigger("event2")
                .withActions(transitioned)
                .build();

        Transition parent_s2_b = Transition.newBuilder()
                .withTrigger("event2")
                .withActions(transitioned)
                .build();

        FSM fsm = FSM.newBuilder()
                .withName("fsm")
                .withOwnedState(parent, s1, s2)
                .withInitialState(s1)
                .withTransitions(s1_parent, parent_s2, parent_s2_b, parent_c2)
                .build();

        c2.getIncomingTransitions().add(parent_c2);
        s2.getIncomingTransitions().add(parent_s2_b);

        if (parent_c2_first) {
            parent.getOutgoingTransitions().add(parent_c2);
            parent.getOutgoingTransitions().add(parent_s2_b);
        } else {
            parent.getOutgoingTransitions().add(parent_s2_b);
            parent.getOutgoingTransitions().add(parent_c2);
        }

        return fsm;
    }

    @Test()
    public void testChildrenDoneEvent() throws InterruptedException {

        for (int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            System.out.println("-------------- testChildrenDoneEvent(), iteration: " + i);

            List<String> actualEvtList = Collections.synchronizedList(new ArrayList<>());

            StateAction entryAction = (s, e) -> {
                actualEvtList.add("enter " + s.getName());
                System.out.println("enter " + s.getName());
            };

            StateAction exitAction = (s, e) -> {
                actualEvtList.add("exit " + s.getName());
                System.out.println("exit " + s.getName());
            };

            TransitionAction transitioned = (t, e) -> {
                actualEvtList.add("transitioning from " + t.getSource().getName()
                        + " to " + t.getTarget().getName() + ", via event " + e.getName());
                System.out.println("transitioning from " + t.getSource().getName()
                        + " to " + t.getTarget().getName() + ", via event " + e.getName());
            };

            State c1 = State.newBuilder()
                    .withName("c1")
                    .build();
            State c2 = State.newBuilder()
                    .withName("c2")
                    .build();

            Transition c1_c2 = Transition.newBuilder()
                    .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                    .withSource(c1)
                    .withTarget(c2)
                    .build();

            FSM childFSM = FSM.newBuilder()
                    .withName("Child FSM")
                    .withInitialState(c1)
                    .withOwnedState(c1, c2)
                    .withFinalState(c2)
                    .withTransitions(c1_c2)
                    .build();

            FSM childFSM1 = childFSM.clone();
            childFSM1.setName("Child FSM 1");
//        childFSM1.setVerbose(true);
            childFSM1.getOwnedState().forEach(s -> s.setName(s.getName() + "-fsm1"));
            FSM childFSM2 = childFSM.clone();
            childFSM2.setName("Child FSM 2");
            childFSM2.getOwnedState().forEach(s -> s.setName(s.getName() + "-fsm2"));

            State s1 = State.newBuilder()
                    .withName("s1")
                    .build();

            AtomicBoolean childFSMStateWasInterrupted = new AtomicBoolean();

            FSMState childFSMState = FSMState.newBuilder()
                    .withName("ChildFSMState")
                    .withFSMs(childFSM1, childFSM2)
                    .withDoAction((s, e) -> {
                        try {
                            System.out.println("!!! cfsm: enter");
                            Thread.sleep(1500);
                            System.out.println("!!! cfsm: exit");
                        } catch (InterruptedException interruptedException) {
                            System.out.println("!!! cfsm: interrupted");
                            Thread.currentThread().interrupt();
                            childFSMStateWasInterrupted.set(true);
                        }
                    })
                    .build();

            AtomicBoolean s2WasInterrupted = new AtomicBoolean();

            State s2 = State.newBuilder()
                    .withName("s2")
                    .withDoAction((s, e) -> {
                        try {
                            System.out.println("!!! s2: enter");
                            Thread.sleep(150);
                            System.out.println("!!! s2: exit");
                        } catch (InterruptedException interruptedException) {
                            System.out.println("!!! s2: interrupt");
                            Thread.currentThread().interrupt();
                            s2WasInterrupted.set(true);
                        }
                    })
                    .build();

            State s3 = State.newBuilder()
                    .withName("s3")
                    .build();

            Transition s1_childFSMState = Transition.newBuilder()
                    .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                    .withSource(s1)
                    .withTarget(childFSMState)
                    .build();

            Transition childFSMState_s2 = Transition.newBuilder()
                    .withTrigger(FSMExecutor.FSMEvents.FINAL_STATE.getName())
                    .withSource(childFSMState)
                    .withTarget(s2)
                    .build();

            Transition s2_s3 = Transition.newBuilder()
                    .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                    .withSource(s2)
                    .withTarget(s3)
                    .build();

            FSM fsm = FSM.newBuilder()
                    .withName("FSM")
                    .withInitialState(s1)
                    .withOwnedState(s1, childFSMState, s2, s3)
                    .withFinalState(s3)
                    .withTransitions(s1_childFSMState, childFSMState_s2, s2_s3)
                    .build();

            fsm.vmf().content().stream(State.class).forEach(s -> {
                s.setOnEntryAction(entryAction);
                s.setOnExitAction(exitAction);
            });

            fsm.vmf().content().stream(Transition.class).forEach(t -> {
                t.getActions().add(transitioned);
            });

            fsm.setVerbose(true);

            var executor = FSMExecutors.newAsyncExecutor(fsm, MODE);

            fsm.setRunning(true);

            while (executor.hasRemainingEvents()) {
                executor.processRemainingEvents();
            }

            if (MODE == AsyncFSMExecutor.ExecutionMode.PARALLEL_REGIONS) {

                Thread.sleep(100); // TODO (hasRemainingEvents() might still be buggy)

                while (executor.hasRemainingEvents()) {
                    executor.processRemainingEvents();
                }
            }

            fsm.setRunning(false);

            var expectedEvtList = Arrays.asList(
                    "enter s1",           // <- fsm:init

                    "exit s1",            // <- fsm:state-done
                    "transitioning from s1 to ChildFSMState, via event fsm:state-done",
                    "enter ChildFSMState",

                    // FSM1 (Region 1)
                    "enter c1-fsm1",      // <- fsm:init

                    "exit c1-fsm1",       // <- fsm:state-done
                    "transitioning from c1-fsm1 to c2-fsm1, via event fsm:state-done",
                    "enter c2-fsm1",

                    "exit c2-fsm1",       // <- fsm stopped (no event generated)

                    // FSM1 (Region 2)
                    "enter c1-fsm2",      // <- fsm:init

                    "exit c1-fsm2",       // <- fsm:state-done
                    "transitioning from c1-fsm2 to c2-fsm2, via event fsm:state-done",
                    "enter c2-fsm2",

                    "exit c2-fsm2",       // <- fsm stopped (no event generated)
                    "exit ChildFSMState", // <- fsm:final-state (all regions of ChildFSMState reached final state)
                    "transitioning from ChildFSMState to s2, via event fsm:final-state",
                    "enter s2",

                    "exit s2",            // <- fsm:state-done (does not interrupt do-action of s2)
                    "transitioning from s2 to s3, via event fsm:state-done",
                    "enter s3",
                    "exit s3"            // <- fsm stopped (no event generated)
            );

            System.out.println("--------------");

            System.out.println(String.join("\n", actualEvtList));

            System.out.println("-------------- END testChildrenDoneEvent(), iteration: " + i);

            // order of child fsms implementation specific
            // (we only test size (number of state transitions + whether do-actions have been interrupted resp. properly executed) )
            Assert.assertEquals(expectedEvtList.size(), actualEvtList.size());

            Assert.assertTrue("do-action of childFSMState should be" +
                            " interrupted since there is a consuming transition that causes childFSMState to exit (evt: fsm:final-state)",
                    childFSMStateWasInterrupted.get());

            Assert.assertFalse("do-action of s2 should not be" +
                            " interrupted since there is no consuming transition that would cause s2 to exit (evt: fsm:state-done)",
                    s2WasInterrupted.get());

        } // end for i

    }

    @Test(timeout = 10000)
    public void testStateDone() throws InterruptedException {

        List<String> actualEvtList = Collections.synchronizedList(new ArrayList<>());

        StateAction entryAction = (s, e) -> {
            actualEvtList.add("enter " + s.getName());
        };

        StateAction exitAction = (s, e) -> {
            actualEvtList.add("exit " + s.getName());
        };

        TransitionAction transitioned = (t, e) -> {
            actualEvtList.add("transitioning from " + t.getSource().getName()
                    + " to " + t.getTarget().getName() + ", via event " + e.getName());
        };

        State s1 = State.newBuilder()
                .withName("s1")
                .build();
        State s2 = State.newBuilder()
                .withName("s2")
                .build();
        State s3 = State.newBuilder()
                .withName("s3")
                .build();

        Transition s1_s2 = Transition.newBuilder()
                .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                .withSource(s1)
                .withTarget(s2)
                .build();

        Transition s2_s3 = Transition.newBuilder()
                .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                .withSource(s2)
                .withTarget(s3)
                .build();

        FSM fsm = FSM.newBuilder()
                .withName("FSM")
                .withInitialState(s1)
                .withOwnedState(s1, s2, s3)
                .withFinalState(s3)
                .withTransitions(s1_s2, s2_s3)
                .build();


        fsm.vmf().content().stream(State.class).forEach(s -> {
            s.setOnEntryAction(entryAction);
            s.setOnExitAction(exitAction);
        });

        fsm.vmf().content().stream(Transition.class).forEach(t -> {
            t.getActions().add(transitioned);
        });

        fsm.setVerbose(true);

        var executor = FSMExecutors.newAsyncExecutor(fsm, MODE);

        fsm.setRunning(true);
        while (executor.hasRemainingEvents()) {
            executor.processRemainingEvents();
        }
        fsm.setRunning(false);

        var expectedEvtList = Arrays.asList(
                "enter s1",           // <- fsm:init

                "exit s1",            // <- fsm:state-done
                "transitioning from s1 to s2, via event fsm:state-done",
                "enter s2",

                "exit s2",            // <- fsm:state-done
                "transitioning from s2 to s3, via event fsm:state-done",
                "enter s3",
                "exit s3"            // <- fsm stopped (no event generated)
        );

        System.out.println(String.join("\n", actualEvtList));

        Assert.assertEquals(expectedEvtList, actualEvtList);

    }

    @Test
    public void errorStateTest1() {
        State s1 = State.newBuilder()
                .withName("s1")
                .build();
        State s2 = State.newBuilder()
                .withName("s1")
                .withOnEntryAction((s, e) -> {
                    throw new RuntimeException("Exception in s2");
                })
                .build();

        Transition s1s2 = Transition.newBuilder()
                .withTrigger("myEvent1")
                .withSource(s1)
                .withTarget(s2)
                .build();

        State error = State.newBuilder()
                .withName("ERROR")
                .withOnEntryAction((s, e) -> System.out.println("Error: " + e.getArgs().get(0)))
                .build();

        FSM fsm = FSM.newBuilder()
                .withName("FSM")
                .withInitialState(s1)
                .withOwnedState(s1, s2, error)
                .withErrorState(error)
                .withTransitions(s1s2)
                .build();

        var executor = FSMExecutors.newAsyncExecutor(fsm, AsyncFSMExecutor.ExecutionMode.SERIAL_REGIONS);

        fsm.setRunning(true);
        executor.process("myEvent1");
        fsm.setRunning(false);


        Assert.assertEquals(fsm.getErrorState(), fsm.getCurrentState());

    }

    @Test
    public void errorStateNestedFSMTest2() {
        State s1 = State.newBuilder()
                .withName("s1")
                .build();
        State s2 = State.newBuilder()
                .withName("s1")
                .withOnEntryAction((s, e) -> {
                    throw new RuntimeException("Exception in s2");
                })
                .build();

        Transition s1s2 = Transition.newBuilder()
                .withTrigger("myEvent1")
                .withSource(s1)
                .withTarget(s2)
                .build();


        FSM fsmChild = FSM.newBuilder()
                .withName("FSM Child")
                .withInitialState(s1)
                .withOwnedState(s1, s2)
                .withTransitions(s1s2)
                .build();

        State error = State.newBuilder()
                .withName("ERROR")
                .withOnEntryAction((s, e) -> System.out.println("Error: " + e.getArgs().get(0)))
                .build();

        FSMState child = FSMState.newBuilder()
                .withName("Region 1")
                .withFSMs(fsmChild)
                .build();

        FSM fsm = FSM.newBuilder()
                .withName("FSM")
                .withInitialState(child)
                .withOwnedState(child, error)
                .withErrorState(error)
                .build();

        var executor = FSMExecutors.newAsyncExecutor(fsm, AsyncFSMExecutor.ExecutionMode.SERIAL_REGIONS);

        fsm.setRunning(true);
        executor.process("myEvent1");
        executor.processRemainingEvents(); // handle exception event
        fsm.setRunning(false);


        Assert.assertEquals(fsm.getErrorState(), fsm.getCurrentState());

    }

    @Test
    public void errorStateNestedFSMTest3() throws InterruptedException, ExecutionException {

        // test whether errors are processed in parent fsms if no error state has been registered
        // in the nested fsm

        State s1 = State.newBuilder()
                .withName("s1")
                .build();
        State s2 = State.newBuilder()
                .withName("s2")
                .withOnEntryAction((s, e) -> {
                    throw new RuntimeException("Exception in s2");
                })
                .build();

        Transition s1s2 = Transition.newBuilder()
                .withTrigger("myEvent1")
                .withSource(s1)
                .withTarget(s2)
                .build();


        FSM fsmChild = FSM.newBuilder()
                .withName("FSM Child")
                .withInitialState(s1)
                .withOwnedState(s1, s2)
                .withTransitions(s1s2)
                .build();

        State error = State.newBuilder()
                .withName("ERROR")
                .withOnEntryAction((s, e) -> System.out.println("Error: " + e.getArgs().get(0)))
                .build();

        FSMState child = FSMState.newBuilder()
                .withName("Region 1")
                .withFSMs(fsmChild)
                .build();

        FSM fsm = FSM.newBuilder()
                .withName("FSM")
                .withVerbose(true)
                .withInitialState(child)
                .withOwnedState(child)
                .withOwnedState(child, error)
                .withErrorState(error)
                .build();

        var executor = FSMExecutors.newAsyncExecutor(fsm, AsyncFSMExecutor.ExecutionMode.SERIAL_REGIONS);
        executor.startAsync();
        Thread.sleep(100);
        executor.trigger("myEvent1");
        Thread.sleep(100);

        Assert.assertEquals(fsm.getErrorState(), fsm.getCurrentState());
        executor.stop();

    }

    @Test(timeout = 100_000)
    public void nestedFSMEventConsumedActionTest() throws InterruptedException, ExecutionException {

        //                +------------------+
        //      +---------+ S3|          R1  |
        //      | s3-done |---/              |
        //      |         |                  |
        //      |         |  +---+ EV1 +---+ |
        //   +--v-+       |  |S1i|---->|S2i| | <------- S2i is final state
        //   | S1 |       |  +---+     +---+ |
        //   +----+       |                  |
        //      |         +------------------+
        //      |         |       ...        |
        //   EV1|         +------------------+
        //      |         |              RN  |
        //      |         |                  |
        //   +--v-+  EV2  |  +---+ EV1 +---+ |
        //   | S2 +------->  |S1i|---->|S2i| | <------- S2i is final state
        //   +----+       |  +---+     +---+ |
        //                |                  |
        //                +------------------+

        // - does each region (R1, R2) consume the event EV1?

        for (int idx = 0; idx < NUM_ITERATIONS_SMALL_TESTS; idx++) {

            var s1EnteredF = new CompletableFuture<Void>();
            State s1 = State.newBuilder()
                    .withName("s1")
                    .withOnEntryAction((s, e) -> {
                        System.out.println("entered state " + s.getName());
                        s1EnteredF.complete(null);
                    })
                    .build();

            State s2 = State.newBuilder()
                    .withName("s2")
                    .withOnEntryAction((s, e) -> {
                        System.out.println("entered state " + s.getName());
                    })
                    .build();

            Function<Integer, FSM> fsmCreator = (i) -> {
                State s1i = State.newBuilder()
                        .withName("s1i")
                        .withOnEntryAction((s, e) -> {
                            System.out.println("cfsm" + i + " entered state " + s.getName());
                            sleepRandom(0, 250);
                        })
                        .build();

                State s2i = State.newBuilder()
                        .withName("s2i")
                        .withOnEntryAction((s, e) -> {
                            System.out.println("cfsm" + i + " entered state " + s.getName());
                            sleepRandom(0, 250);
                        })
                        .build();

                Transition s1s2i = Transition.newBuilder()
                        .withTrigger("EV1")
                        .withSource(s1i)
                        .withTarget(s2i)
                        .build();

                FSM fsmChild = FSM.newBuilder()
                        .withName("Child " + i)
                        .withInitialState(s1i)
                        .withOwnedState(s1i, s2i)
                        .withTransitions(s1s2i)
                        .withFinalState(s2i)
                        .build();

                return fsmChild;
            };

            int numberOFChildren = ThreadLocalRandom.current().nextInt(30) + 1;

            var childFSMs = IntStream.range(1, numberOFChildren + 1)
                    .mapToObj(i -> fsmCreator.apply(i)).collect(Collectors.toList());

            var s3EnteredF = new CompletableFuture<Void>();
            FSMState s3 = FSMState.newBuilder()
                    .withName("s3")
                    .withFSMs(childFSMs)
                    .withOnEntryAction((s, e) -> {
                        System.out.println("entering state " + s.getName());
                        s3EnteredF.complete(null);
                    })
                    .build();

            Transition s1s2 = Transition.newBuilder()
                    .withTrigger("EV1")
                    .withSource(s1)
                    .withTarget(s2)
                    .build();

            Transition s2s3 = Transition.newBuilder()
                    .withTrigger("EV2")
                    .withSource(s2)
                    .withTarget(s3)
                    .build();

            var s3s1F = new CompletableFuture<>();
            Transition s3s1 = Transition.newBuilder()
                    .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                    .withSource(s3)
                    .withTarget(s1)
                    .withActions((t, e) -> {
                        System.out.println("transitioning from S3 to S1");
                        s3s1F.complete(null);
                    })
                    .build();

            FSM fsm = FSM.newBuilder()
                    .withName("FSM")
                    .withInitialState(s1)
                    .withOwnedState(s1, s2, s3)
                    .withTransitions(s1s2, s1s2, s2s3, s3s1)
                    .withVerbose(true)
                    .build();

            var mode = idx % 2 == 0
                    ? AsyncFSMExecutor.ExecutionMode.SERIAL_REGIONS
                    : AsyncFSMExecutor.ExecutionMode.PARALLEL_REGIONS;

            System.out.println("> running executor with " + mode.name() + ", n-child-fsms: " + numberOFChildren);
            var executor = FSMExecutors.newAsyncExecutor(fsm, AsyncFSMExecutor.ExecutionMode.PARALLEL_REGIONS);

            executor.startAsync();

            s1EnteredF.join();

            {
                var f = new CompletableFuture<Void>();
                System.out.println("> triggering event 1");
                executor.trigger("EV1", (e, t) -> {
                    System.out.println("myEvent1 consumed");
                    f.complete(null);
                });
                f.join();
            }

            {
                var f = new CompletableFuture<Void>();
                System.out.println("> triggering event 2");
                executor.trigger("EV2", (e, t) -> {
                    System.out.println("EV2 consumed");
                    f.complete(null);
                });
                f.join();
            }

            s3EnteredF.join();

            var consumeCount = new AtomicInteger();
            {
                System.out.println("> triggering event 1");
                executor.trigger("EV1", (e, t) -> {
                    System.out.println("EV1 consumed for inner by state "
                            + t.getTarget().getName() + " in fsm " + t.getOwningFSM().getName()
                    );
                    consumeCount.incrementAndGet();
                });
            }

            s3s1F.join();

            executor.stop();

            Assert.assertEquals(
                    "EV1 should be consumed by each region R1..R" + numberOFChildren,
                    numberOFChildren, consumeCount.get()
            );

        }

    }

    @Test(timeout = 100_000)
    public void nestedFSMEventConsumedActionTest2() throws InterruptedException, ExecutionException {

        //                +------------------+
        //      +---------+ S3|          R1  |
        //      |    EV3  |---/              |
        //      |         |                  |
        //      |         |  +---+ EV1 +---+ |
        //   +--v-+       |  |S1i|---->|S2i| | <------- S2i is non-final state
        //   | S1 |       |  +---+     +---+ |
        //   +----+       |                  |
        //      |         +------------------+
        //      |         |       ...        |
        //   EV1|         +------------------+
        //      |         |              RN  |
        //      |         |                  |
        //   +--v-+  EV2  |  +---+ EV1 +---+ |
        //   | S2 +------->  |S1i|---->|S2i| | <------- S2i is non-final state
        //   +----+       |  +---+     +---+ |
        //                |                  |
        //                +------------------+

        // - does each region (R1, R2) consume the event EV1?

        for (int idx = 0; idx < NUM_ITERATIONS_SMALL_TESTS; idx++) {

            var s1EnteredF = new CompletableFuture<Void>();
            State s1 = State.newBuilder()
                    .withName("s1")
                    .withOnEntryAction((s, e) -> {
                        System.out.println("entered state " + s.getName()
                                + " " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date()));
                        s1EnteredF.complete(null);
                    })
                    .build();

            State s2 = State.newBuilder()
                    .withName("s2")
                    .withOnEntryAction((s, e) -> {
                        System.out.println("entered state " + s.getName()
                                + " " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date())
                        );
                    })
                    .build();

            Function<Integer, FSM> fsmCreator = (i) -> {
                State s1i = State.newBuilder()
                        .withName("s1i")
                        .withOnEntryAction((s, e) -> {
                            System.out.println("cfsm" + i + " entered state " + s.getName()
                                    + " " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date())
                            );
                            sleepRandom(0, 250);
                        })
                        .build();

                State s2i = State.newBuilder()
                        .withName("s2i")
                        .withOnEntryAction((s, e) -> {
                            System.out.println("cfsm" + i + " entered state " + s.getName()
                                    + " " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date()));
                            sleepRandom(0, 250);
                        })
                        .build();

                Transition s1s2i = Transition.newBuilder()
                        .withTrigger("EV1")
                        .withSource(s1i)
                        .withTarget(s2i)
                        .build();

                FSM fsmChild = FSM.newBuilder()
                        .withName("Child " + i)
                        .withInitialState(s1i)
                        .withOwnedState(s1i, s2i)
                        .withTransitions(s1s2i)
                        .withFinalState(s2i)
                        .build();

                return fsmChild;
            };

            int numberOFChildren = ThreadLocalRandom.current().nextInt(30) + 1;

            var childFSMs = IntStream.range(1, numberOFChildren + 1)
                    .mapToObj(i -> fsmCreator.apply(i)).collect(Collectors.toList());

            var s3EnteredF = new CompletableFuture<Void>();
            FSMState s3 = FSMState.newBuilder()
                    .withName("s3")
                    .withFSMs(childFSMs)
                    .withOnEntryAction((s, e) -> {
                        System.out.println("entering state " + s.getName()
                                + " " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date()));
                        s3EnteredF.complete(null);
                    })
                    .build();

            Transition s1s2 = Transition.newBuilder()
                    .withTrigger("EV1")
                    .withSource(s1)
                    .withTarget(s2)
                    .build();

            Transition s2s3 = Transition.newBuilder()
                    .withTrigger("EV2")
                    .withSource(s2)
                    .withTarget(s3)
                    .build();

            Transition s3s1 = Transition.newBuilder()
                    .withTrigger("EV3")
                    .withSource(s3)
                    .withTarget(s1)
                    .withActions((t, e) -> System.out.println("transitioning from S3 to S1"))
                    .build();

            FSM fsm = FSM.newBuilder()
                    .withName("FSM")
                    .withInitialState(s1)
                    .withOwnedState(s1, s2, s3)
                    .withTransitions(s1s2, s1s2, s2s3, s3s1)
                    .withVerbose(true)
                    .build();


            var mode = idx % 2 == 0
                    ? AsyncFSMExecutor.ExecutionMode.SERIAL_REGIONS
                    : AsyncFSMExecutor.ExecutionMode.PARALLEL_REGIONS;

            System.out.println("> running executor with " + mode.name() + ", n-child-fsms: " + numberOFChildren);
            var executor = FSMExecutors.newAsyncExecutor(fsm, mode);

            executor.startAsync();

            s1EnteredF.join();

            {
                var f = new CompletableFuture<Void>();
                System.out.println("> triggering event 1");
                executor.trigger("EV1", (e, t) -> {
                    System.out.println("EV1 consumed "
                            + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date()));
                    f.complete(null);
                });
                f.join();
            }

            {
                var f = new CompletableFuture<Void>();
                System.out.println("> triggering event 2");
                executor.trigger("EV2", (e, t) -> {
                    System.out.println("EV2 consumed "
                            + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date())
                    );
                    f.complete(null);
                });
                f.join();
            }

            s3EnteredF.join();

            var consumeCount = new AtomicInteger();
            {
                var f = new CompletableFuture<Void>();
                System.out.println("> triggering event 1");
                executor.trigger("EV1", (e, t) -> {
                    System.out.println("EV1 consumed for inner by state "
                            + t.getTarget().getName() + " in fsm " + t.getOwningFSM().getName()
                            + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date())
                    );
                    consumeCount.incrementAndGet();
                    f.complete(null);
                });
                f.join();
            }

            {
                System.out.println("> triggering event 3");
                var f = new CompletableFuture<Void>();
                executor.trigger("EV3", (e, t) -> {
                    f.complete(null);
                    System.out.println("EV3 consumed"
                            + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date())
                    );
                });
                f.join();
            }

            executor.stop();

            Assert.assertEquals(
                    "EV1 should be consumed by each region R1..R" + numberOFChildren,
                    numberOFChildren, consumeCount.get()
            );
        }
    }


    @Test(timeout = 100_000)
    public void nestedFSM() throws InterruptedException, ExecutionException {

        //                +------------------+
        //      +---------+ S3|          R1  |
        //      |    EV3  |---/              |
        //      |         |                  |
        //      |         |  +---+ EV1 +---+ |
        //   +--v-+       |  |S1i|---->|S2i| | <------- S2i is non-final state
        //   | S1 |       |  +---+     +---+ |
        //   +----+       |                  |
        //      |         +------------------+
        //      |         |       ...        |
        //   EV1|         +------------------+
        //      |         |              RN  |
        //      |         |                  |
        //   +--v-+  EV2  |  +---+ EV1 +---+ |
        //   | S2 +------->  |S1i|---->|S2i| | <------- S2i is non-final state
        //   +----+       |  +---+     +---+ |
        //                |                  |
        //                +------------------+

        // - does each region (R1, R2) consume the event EV1?

        for (int idx = 0; idx < NUM_ITERATIONS_SMALL_TESTS; idx++) {

            var s1EnteredF = new CompletableFuture<Void>();
            State s1 = State.newBuilder()
                    .withName("s1")
                    .withOnEntryAction((s, e) -> {
                        System.out.println("entered state " + s.getName());
                        s1EnteredF.complete(null);
                    })
                    .build();

            State s2 = State.newBuilder()
                    .withName("s2")
                    .withOnEntryAction((s, e) -> {
                        System.out.println("entered state " + s.getName());
                    })
                    .build();

            Function<Integer, FSM> fsmCreator = (i) -> {
                State s1i = State.newBuilder()
                        .withName("s1i")
                        .withOnEntryAction((s, e) -> {
                            System.out.println("cfsm" + i + " entered state " + s.getName());
                            sleepRandom(0, 250);
                        })
                        .build();

                State s2i = State.newBuilder()
                        .withName("s2i")
                        .withOnEntryAction((s, e) -> {
                            System.out.println("cfsm" + i + " entered state " + s.getName());
                            sleepRandom(0, 250);
                        })
                        .build();

                Transition s1s2i = Transition.newBuilder()
                        .withTrigger("EV1")
                        .withSource(s1i)
                        .withTarget(s2i)
                        .build();

                FSM fsmChild = FSM.newBuilder()
                        .withName("Child " + i)
                        .withInitialState(s1i)
                        .withOwnedState(s1i, s2i)
                        .withTransitions(s1s2i)
                        .withFinalState(s2i)
                        .build();

                return fsmChild;
            };

            int numberOFChildren = ThreadLocalRandom.current().nextInt(30) + 1;

            var childFSMs = IntStream.range(1, numberOFChildren + 1)
                    .mapToObj(i -> fsmCreator.apply(i)).collect(Collectors.toList());

            var s3EnteredF = new CompletableFuture<Void>();
            FSMState s3 = FSMState.newBuilder()
                    .withName("s3")
                    .withFSMs(childFSMs)
                    .withOnEntryAction((s, e) -> {
                        System.out.println("entering state " + s.getName());
                        s3EnteredF.complete(null);
                    })
                    .build();

            Transition s1s2 = Transition.newBuilder()
                    .withTrigger("EV1")
                    .withSource(s1)
                    .withTarget(s2)
                    .build();

            Transition s2s3 = Transition.newBuilder()
                    .withTrigger("EV2")
                    .withSource(s2)
                    .withTarget(s3)
                    .build();

            Transition s3s1 = Transition.newBuilder()
                    .withTrigger("EV3")
                    .withSource(s3)
                    .withTarget(s1)
                    .withActions((t, e) -> System.out.println("transitioning from S3 to S1"))
                    .build();


            FSM fsm = FSM.newBuilder()
                    .withName("FSM")
                    .withInitialState(s1)
                    .withOwnedState(s1, s2, s3)
                    .withTransitions(s1s2, s1s2, s2s3, s3s1)
                    .withVerbose(true)
                    .build();


            var mode = idx % 2 == 0
                    ? AsyncFSMExecutor.ExecutionMode.SERIAL_REGIONS
                    : AsyncFSMExecutor.ExecutionMode.PARALLEL_REGIONS;

            System.out.println("> running executor with " + mode.name() + ", n-child-fsms: " + numberOFChildren);
            var executor = FSMExecutors.newAsyncExecutor(fsm, AsyncFSMExecutor.ExecutionMode.PARALLEL_REGIONS);

            executor.startAsync();

            s1EnteredF.join();

            {
                var f = new CompletableFuture<Void>();
                System.out.println("> triggering event 1");
                executor.trigger("EV1", (e, t) -> {
                    System.out.println("EV1 consumed "
                            + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date())
                    );
                    f.complete(null);
                });
                f.join();
            }

            {
                var f = new CompletableFuture<Void>();
                System.out.println("> triggering event 2");
                executor.trigger("EV2", (e, t) -> {
                    System.out.println("EV2 consumed "
                            + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date())
                    );
                    f.complete(null);
                });
                f.join();
            }

            s3EnteredF.join();

            var consumeCount = new AtomicInteger();
            {
                var f = new CompletableFuture<Void>();
                System.out.println("> triggering event 1");
                executor.trigger("EV1", (e, t) -> {
                    System.out.println("EV1 consumed for inner by state "
                            + t.getTarget().getName() + " in fsm " + t.getOwningFSM().getName() + " "
                            + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date())
                    );
                    consumeCount.incrementAndGet();
                    f.complete(null);
                });
                f.join();
            }

            {
                System.out.println("> triggering event 3");
                var f = new CompletableFuture<Void>();
                executor.trigger("EV3", (e, t) -> {
                    f.complete(null);
                    System.out.println("EV3 consumed: "
                            + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date())
                    );
                });
                f.join();
            }

            executor.stop();

            Assert.assertEquals(
                    "EV1 should be consumed by each region R1..R" + numberOFChildren,
                    numberOFChildren, consumeCount.get()
            );
        }
    }

    @Test(timeout = 10_000)
    public void nestedFSMState() throws InterruptedException, ExecutionException {

        //                +--------------------------------------+
        //                | B |                                  |
        //                |---/                                  |
        //      +---------|--------------+                       |
        //      |         |              |                       |
        //    +---+       |  +---+     +-v-+     +---+     +---+ |      +---+
        //    | A |       |  | D |---->| E |---->| F |---->| G | |----->| C |
        //    +---+       |  +---+     +---+     +---+     +---+ |      +---+
        //                |                                      |
        //                +--------------------------------------+

        //  G is the final state of the nested FSM in state B
        //  C is the final state of the top level FSM

        // - Q: Does the transition from A directly to E work?
        //      Or is the nested FSM going through D first?

        var list = new ConcurrentLinkedDeque<String>();

        Function<String, State> createState = (name) -> State.newBuilder()
                .withName(name)
                .withOnEntryAction((s, e) -> {
                    var msg = "entered state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .build();


        State A = createState.apply("A");
        State C = createState.apply("C");
        State D = createState.apply("D");
        State E = createState.apply("E");
        State F = createState.apply("F");
        State G = createState.apply("G");

        Transition DE = Transition.newBuilder()
                .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                .withSource(D)
                .withTarget(E)
                .build();

        Transition EF = Transition.newBuilder()
                .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                .withSource(E)
                .withTarget(F)
                .build();

        Transition FG = Transition.newBuilder()
                .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                .withSource(F)
                .withTarget(G)
                .build();

        FSM nestedFSM = FSM.newBuilder()
                .withName("nested FSM")
                .withInitialState(D)
                .withFinalState(G)
                .withOwnedState(D, E, F, G)
                .withTransitions(DE, EF, FG)
                .withVerbose(true)
                .build();

        FSMState B = FSMState.newBuilder()
                .withName("B")
                .withOnEntryAction((s, ev) -> {
                    var msg = "entered state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .withFSMs(nestedFSM)
                .build();

//        Transition AB = Transition.newBuilder()
//                .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
//                .withSource(A)
//                .withTarget(B)
//                .build();

        Transition AE = Transition.newBuilder()
                .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                .withSource(A)
                .withTarget(E)
                .build();

        Transition BC = Transition.newBuilder()
                .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                .withSource(B)
                .withTarget(C)
                .build();

//        FSM fsm1 = FSM.newBuilder()
//                .withName("FSM")
//                .withInitialState(A)
//                .withFinalState(C)
//                .withOwnedState(A,B,C)
//                .withTransitions(
//                    AB,
//                    BC
//                )
//                .withVerbose(true)
//                .build();

        FSM fsm2 = FSM.newBuilder()
                .withName("FSM")
                .withInitialState(A)
                .withFinalState(C)
                .withOwnedState(A, B, C)
                .withTransitions(
                        AE,
//                    AB,
                        BC
                )
                .withVerbose(true)
                .build();

        var executor = FSMExecutors.newAsyncExecutor(fsm2);

        executor.startAndWait();

        Assert.assertEquals(List.of(
                "entered state A",
                "entered state B",
                "entered state E",
                "entered state F",
                "entered state G",
                "entered state C"
        ).toArray(), list.toArray());

    }

    @Test(timeout = 10_000)
    public void testDirectToNestedState() {
        //
        //
        //
        //         +---------------------------------------------+
        //         | B  |                                        |
        //         |---/     +-------------------------+         |
        //         |         | E  |                    |         |
        //  +---+  |         |---/                     |         |
        //  | A +--+---------+------------+            |         |
        //  +---+  |         |            |            |         |
        //         |         |            |            |         |
        //         |  +---+  |  +---+   +-v-+   +---+  |  +---+  |  +---+
        //         |  | D +-->  | G +---> H +---> I |  +--> F |  +--> C |
        //         |  +---+  |  +---+   +---+   +---+  |  +---+  |  +---+
        //         |         |                         |         |
        //         |         |                         |         |
        //         |         |                         |         |
        //         |         +-------------------------+         |
        //         |                                             |
        //         +---------------------------------------------+
        //

        // create fsm according to upper diagram

        // B, E are FSMStates with a single region, the other states are normal states

        // create a list to store the state entry messages
        var list = new ConcurrentLinkedDeque<String>();

        // create a VSM model with nested fsm states

        Function<String, State> createState = (name) -> State.newBuilder()
                .withName(name)
                .withOnEntryAction((s, e) -> {
                    var msg = "entered state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .build();

        // create states
        var A = createState.apply("A");
        var C = createState.apply("C");
        var D = createState.apply("D");
        var F = createState.apply("F");
        var G = createState.apply("G");
        var H = createState.apply("H");
        var I = createState.apply("I");

        // create fsm states with nested fsms
        var E = FSMState.newBuilder()
                .withName("E")
                .withOnEntryAction((s, e) -> {
                    var msg = "entered FSM state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .withFSMs(
                        FSM.newBuilder()
                                .withName("nested FSM E")
                                .withInitialState(G)
                                .withFinalState(I)
                                .withOwnedState(G, H, I)
                                .withTransitions(
                                        Transition.newBuilder()
                                                .withTrigger(
                                                        FSMExecutor.FSMEvents.STATE_DONE.getName()
                                                )
                                                .withSource(G)
                                                .withTarget(H)
                                                .build(),
                                        Transition.newBuilder()
                                                .withTrigger(
                                                        FSMExecutor.FSMEvents.STATE_DONE.getName()
                                                )
                                                .withSource(H)
                                                .withTarget(I)
                                                .build()
                                )
                                .withVerbose(true)
                                .build()
                )
                .build();


        var B = FSMState.newBuilder()
                .withName("B")
                .withOnEntryAction((s, e) -> {
                    var msg = "entered FSM state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .withFSMs(
                        FSM.newBuilder()
                                .withName("nested FSM B")
                                .withInitialState(D)
                                .withFinalState(F)
                                .withOwnedState(D, E, F)
                                .withTransitions(
                                        Transition.newBuilder()
                                                .withTrigger(
                                                        FSMExecutor.FSMEvents.STATE_DONE.getName()
                                                )
                                                .withSource(D)
                                                .withTarget(E)
                                                .build(),
                                        Transition.newBuilder()
                                                .withTrigger(
                                                        FSMExecutor.FSMEvents.STATE_DONE.getName()
                                                )
                                                .withSource(E)
                                                .withTarget(F)
                                                .build()
                                )
                                .withVerbose(true)
                                .build()
                )
                .build();

        // first, create the root fsm
        var root = FSM.newBuilder()
                .withName("root")
                .withInitialState(A)
                .withFinalState(C)
                .withOwnedState(A, B, C)
                .withTransitions(
                        Transition.newBuilder()
                                .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                                .withSource(B)
                                .withTarget(C)
                                .build(),
                        Transition.newBuilder()
                                .withTrigger(
                                        FSMExecutor.FSMEvents.STATE_DONE.getName()
                                )
                                .withSource(A)
                                .withTarget(H)
                                .build()
                )
                .withVerbose(true)
                .build();

        // create the executor
        var executor = FSMExecutors.newAsyncExecutor(root);

        // start the executor
        executor.startAndWait();

        // list
        var expected = List.of(
                "entered state A",
                "entered FSM state B",
//                "entered state D", initial state of nested fsm B, not entered in this case, see diagram!
                "entered FSM state E",
//                "entered state G", initial state of nested fsm E, not entered in this case, see diagram!
                "entered state H",
                "entered state I",
                "entered state F",
                "entered state C"
        );

        // check the result
        Assert.assertEquals(expected.toArray(), list.toArray());
    }


    @Test(timeout = 5_000)
    public void testNestedFSMInnerToInner() {
        //
        //             +---------------------------------------------+
        //             | B  |                                        |
        //             |---/     +-------------------------+         |
        //      +---+  |         | E |                     |         |
        //      | A +-->         |---/                     |         |
        //      +---+  |         |                         |         |
        //             |  +---+  |  +---+   +---+   +---+  |  +---+  |  +---+
        //             |  | D +-->  | G +---> H +---> I |  +--> F |  +--> C |
        //             |  +---+  |  +---+   +-+-+   +---+  |  +---+  |  +-+-+
        //             |         |            |            |         |    |
        //             |         +------------+------------+         |    |
        //             |                      |                      |    |
        //             +----------------------+----------------------+    |
        //                                    |                           |
        //                                    |                           |
        //             +----------------------+----------------------+    |
        //             | J |                  |                      |    |
        //             |---/     +------------+------------+         <----+
        //             |         | M |        |            |         |
        //             |         |---/        |            |         |
        //             |         |            |            |         |
        //             |  +---+  |  +---+   +-v-+   +---+  |  +---+  |  +---+
        //             |  | L +-->  | O +---> P +---> Q |  +--> N |  +--> K |
        //             |  +---+  |  +---+   +---+   +---+  |  +---+  |  +---+
        //             |         |                         |         |
        //             |         +-------------------------+         |
        //             |                                             |
        //             +---------------------------------------------+
        //

        // create a list to store the messages
        var list = new ConcurrentLinkedDeque<String>();

        Function<String, State> createState = (name) -> State.newBuilder()
                .withName(name)
                .withOnEntryAction((s, e) -> {
                    var msg = "entered state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .withOnExitAction((s, e) -> {
                    var msg = "exited state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .build();

        // B, E, J, M are nested fsm states

        // create the regular states
        var A = createState.apply("A");
        var C = createState.apply("C");
        var D = createState.apply("D");
        var F = createState.apply("F");
        var G = createState.apply("G");
        var H = createState.apply("H");
        var I = createState.apply("I");
        var K = createState.apply("K");
        var L = createState.apply("L");
        var N = createState.apply("N");
        var O = createState.apply("O");
        var P = createState.apply("P");
        var Q = createState.apply("Q");

        // create the nested fsm states
        var E = FSMState.newBuilder()
                .withName("E")
                .withOnEntryAction((s, e) -> {
                    var msg = "entered FSM state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .withOnExitAction((s, e) -> {
                    var msg = "exited FSM state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .withFSMs(
                        FSM.newBuilder()
                                .withName("nested FSM E")
                                .withInitialState(G)
                                .withFinalState(I)
                                .withOwnedState(G, H, I)
                                .withTransitions(
                                        // transition from nested fsm state H to P
                                        Transition.newBuilder()
                                                .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                                                .withSource(H)
                                                .withTarget(P)
                                                .build(),
                                        Transition.newBuilder()
                                                .withTrigger(
                                                        FSMExecutor.FSMEvents.STATE_DONE.getName()
                                                )
                                                .withSource(G)
                                                .withTarget(H)
                                                .build(),
                                        Transition.newBuilder()
                                                .withTrigger(
                                                        FSMExecutor.FSMEvents.STATE_DONE.getName()
                                                )
                                                .withSource(H)
                                                .withTarget(I)
                                                .build()
                                )
                                .withVerbose(true)
                                .build()
                )
                .build();

        var B = FSMState.newBuilder()
                .withName("B")
                .withOnEntryAction((s, e) -> {
                    var msg = "entered FSM state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .withOnExitAction((s, e) -> {
                    var msg = "exited FSM state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .withFSMs(
                        FSM.newBuilder()
                                .withName("nested FSM B")
                                .withInitialState(D)
                                .withFinalState(F)
                                .withOwnedState(D, E, F)
                                .withTransitions(
                                        Transition.newBuilder()
                                                .withTrigger(
                                                        FSMExecutor.FSMEvents.STATE_DONE.getName()
                                                )
                                                .withSource(D)
                                                .withTarget(E)
                                                .build(),
                                        Transition.newBuilder()
                                                .withTrigger(
                                                        FSMExecutor.FSMEvents.STATE_DONE.getName()
                                                )
                                                .withSource(E)
                                                .withTarget(F)
                                                .build()
                                )
                                .withVerbose(true)
                                .build()
                )
                .build();


        // M with nested FSM and states O, P, Q
        var M = FSMState.newBuilder()
                .withName("M")
                .withOnEntryAction((s, e) -> {
                    var msg = "entered FSM state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .withOnExitAction((s, e) -> {
                    var msg = "exited FSM state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .withFSMs(
                        FSM.newBuilder()
                                .withName("nested FSM M")
                                .withInitialState(O)
                                .withFinalState(Q)
                                .withOwnedState(O, P, Q)
                                .withTransitions(
                                        Transition.newBuilder()
                                                .withTrigger(
                                                        FSMExecutor.FSMEvents.STATE_DONE.getName()
                                                )
                                                .withSource(O)
                                                .withTarget(P)
                                                .build(),
                                        Transition.newBuilder()
                                                .withTrigger(
                                                        FSMExecutor.FSMEvents.STATE_DONE.getName()
                                                )
                                                .withSource(P)
                                                .withTarget(Q)
                                                .build()
                                )
                                .withVerbose(true)
                                .build()
                ).build();


        var J = FSMState.newBuilder()
                .withName("J")
                .withOnEntryAction((s, e) -> {
                    var msg = "entered FSM state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .withOnExitAction((s, e) -> {
                    var msg = "exited FSM state " + s.getName();
                    System.out.println(msg);
                    list.add(msg);
                })
                .withFSMs(
                        FSM.newBuilder()
                                .withName("nested FSM J")
                                .withInitialState(L)
                                .withFinalState(N)
                                .withOwnedState(L, M, N)
                                .withTransitions(
                                        Transition.newBuilder()
                                                .withTrigger(
                                                        FSMExecutor.FSMEvents.STATE_DONE.getName()
                                                )
                                                .withSource(L)
                                                .withTarget(M)
                                                .build(),
                                        Transition.newBuilder()
                                                .withTrigger(
                                                        FSMExecutor.FSMEvents.STATE_DONE.getName()
                                                )
                                                .withSource(M)
                                                .withTarget(N)
                                                .build()
                                )
                                .withVerbose(true)
                                .build()
                ).build();


        // create the root fsm with states A, B, C, J, K
        // and transitions with trigger 'state-done'
        var root = FSM.newBuilder()
                .withName("root FSM")
                .withInitialState(A)
                .withFinalState(K)
                .withOwnedState(A, B, C, J, K)
                .withTransitions(
                        Transition.newBuilder()
                                .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                                .withSource(A)
                                .withTarget(B)
                                .build(),
                        Transition.newBuilder()
                                .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                                .withSource(B)
                                .withTarget(C)
                                .build(),
                        Transition.newBuilder()
                                .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                                .withSource(C)
                                .withTarget(J)
                                .build(),
                        Transition.newBuilder()
                                .withTrigger(FSMExecutor.FSMEvents.STATE_DONE.getName())
                                .withSource(J)
                                .withTarget(K)
                                .build()

                )
                .withVerbose(true)
                .build();

        // create the fsm executor and execute the fsm
        var fsmExecutor = FSMExecutors.newAsyncExecutor(root);

        // start the fsm executor
        fsmExecutor.startAndWait();

        // check the result
        Assert.assertEquals(List.of(
                "entered state A",
                "exited state A",
                "entered FSM state B",
                "entered state D",
                "exited state D",
                "entered FSM state E",
                "entered state G",
                "exited state G",
                "entered state H",
                "exited state H",
                "exited FSM state E",
                "exited FSM state B",
                "entered FSM state J",
                "entered FSM state M",
                "entered state P",
                "exited state P",
                "entered state Q",
                "exited state Q",
                "exited FSM state M",
                "entered state N",
                "exited state N",
                "exited FSM state J",
                "entered state K",
                "exited state K"
        ).toArray(), list.toArray());


    }
}
