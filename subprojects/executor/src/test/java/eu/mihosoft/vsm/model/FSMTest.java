/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package eu.mihosoft.vsm.model;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

import eu.mihosoft.vsm.executor.Executor;
import org.junit.Assert;
import org.junit.Test;

import java.util.*;
import java.util.stream.Collectors;

public class FSMTest {
    @Test public void testATMFSM() throws InterruptedException {
        State idleState = State.newBuilder().withName("idle").withOnEntryAction(
                (s,e) -> {
                    System.out.println("Machine Idle State");
                }).build();

        State cardInserted = State.newBuilder().withName("cardInserted")
                .withOnEntryAction((s,e) -> {
                    System.out.println("Card Inserted State");
                }).build();

        State pinEnteredState = State.newBuilder().withName("pinEntered")
                .withOnEntryAction((s,e) -> {
                    System.out.println("Pin Entered State");
                }).build();

        State amountRequested = State.newBuilder().withName("amountRequested")
                .withOnEntryAction((s,e) -> {
                    System.out.println("Amount Requested State");
                }).build();

        Transition insertCardTransition = Transition.newBuilder().withTrigger("insert-card")
                .withGuard((t, evt)->{
                    if(evt.getArgs().isEmpty()) return false;
                    return Objects.equals("DE6594339437", evt.getArgs().get(0));
                })
                .withActions((s,e) -> {
                    System.out.println("-> correct card inserted");
                }).withSource(idleState).withTarget(cardInserted).build();

        Transition enterPinTransition = Transition.newBuilder().withTrigger("enter-pin")
                .withGuard((t,evt) -> {
                    System.out.println("-> pin entered");
                    System.out.println("-> checking...");

                    try {
                        Thread.sleep(2500);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }

                    if(evt.getArgs().isEmpty()) {
                        return false;
                    }

                    return Objects.equals(1234, evt.getArgs().get(0));
                }).withActions((s,e) -> {
                    System.out.println("-> valid.");
                }).withSource(cardInserted).withTarget(pinEnteredState).build();

        Transition requestAmountTransition = Transition.newBuilder().withTrigger("request-amount")
                .withActions((s,e) -> {
                    System.out.println("-> amount-requested");
                }).withSource(pinEnteredState).withTarget(amountRequested).build();

        Transition moneyDispatchedTransition = Transition.newBuilder().withTrigger("dispatch-money")
                .withActions((s,e) -> {
                    System.out.println("-> checking whether requested amount is available");
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException ex) {
                        // TODO Auto-generated catch block
                        ex.printStackTrace();
                    }
                    System.out.println("-> money-dispatched");
                })
                .withSource(amountRequested)
                .withTarget(idleState)
                .build();

        State errorState = State.newBuilder()
                .withName("Error")
                .withOnEntryAction((state, event)->{
                    System.out.println("ERROR: ");
                })
                .build();

        FSM fsm = FSM.newBuilder()
                .withName("ATM")
                .withOwnedState(
                        idleState, cardInserted, pinEnteredState, amountRequested,errorState
                )
                .withInitialState(idleState)
                .withErrorState(errorState)
                .withTransitions(
                        insertCardTransition,
                        enterPinTransition,
                        requestAmountTransition,
                        moneyDispatchedTransition
                )
                .withVerbose(true)
                .build();

        var visitedStates = Collections.synchronizedList(new ArrayList<State>());

        fsm.vmf().reflect().propertyByName("currentState").orElseThrow().addChangeListener(change->{
            var oldV = (State)change.propertyChange().orElseThrow().oldValue();
            var newV = (State)change.propertyChange().orElseThrow().newValue();
            System.out.println("> transitioned from " + (oldV==null?"<undefined>":oldV.getName()) + " to " + newV.getName());
            if(newV!=null) {
                visitedStates.add(newV);
            }
        });

        Executor executor = Executor.newInstance(fsm);

        executor.startAsync();

        Thread.sleep(1500);
        
        executor.trigger("insert-card", "DE6594339437");

        Thread.sleep(500);

        executor.trigger("enter-pin", 1234);

        Thread.sleep(500);

        executor.trigger("request-amount", 350);

        executor.trigger("dispatch-money", 350);

        Thread.sleep(4000);

        executor.stop();

        System.out.println("> Visited States: "
                +visitedStates.stream().map(s->s.getName()).
                collect(Collectors.joining(", "))
        );

        assertThat(visitedStates, contains(
                idleState,
                cardInserted,
                pinEnteredState,
                amountRequested,
                idleState
                )
        );

    }

    @Test
    public void nestedOrthogonalWithDoActionProcessingTest() {

        var actualEvtList = new ArrayList<String>();

        FSM fsm = createNestedWithOrthogonal(actualEvtList);

        Executor executor = Executor.newInstance(fsm);
//        executor.startAsync();
        fsm.setRunning(true);
        executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        //executor.process("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));

        while(executor.hasRemainingEvents()) {
            executor.processRemainingEvents();
        }

        fsm.setRunning(false);

        var expectedEvtList = Arrays.asList(
                "enter state a",               // <- fsm:init
                "exit state a",                // <- myEvent 1
                "enter state b",               //
                "exit state b",                // <- myEvent 2
                "enter state c",               //
                "enter do-action-in-state-c",  //
                "enter state ca1",             //
                "enter state ca2",             //
                "exit state ca2",              // <- myEvent 2
                "enter state cb2",             //
                "exit state ca1",              // <- myEvent 1
                "enter state cb1",             //
                "exit do-action-in-state-c",   // <- timeout (sleep)
                "exit state cb1",              // <- fsm:on-do-action-done
                "exit state cb2",              //
                "exit state c",                //
                "enter state a"                //
        );

        Assert.assertEquals(expectedEvtList,actualEvtList);
    }

    @Test
    public void nestedOrthogonalWithDoActionInterruptedProcessingTest() {

        var actualEvtList = new ArrayList<String>();

        FSM fsm = createNestedWithOrthogonal(actualEvtList);

        Executor executor = Executor.newInstance(fsm);

        fsm.setRunning(true);
        executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        executor.process("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));

        while(executor.hasRemainingEvents()) {
            executor.processRemainingEvents();
        }

        fsm.setRunning(false);

        var expectedEvtList = Arrays.asList(
                "enter state a",                   // <- fsm:init
                "exit state a",                    // <- myEvent 1
                "enter state b",                   //
                "exit state b",                    // <- myEvent 2
                "enter state c",                   //
                "enter do-action-in-state-c",      //
                "enter state ca1",                 //
                "enter state ca2",                 //
                "exit state ca2",                  // <- myEvent 2
                "enter state cb2",                 //
                "exit state ca1",                  // <- myEvent 1
                "enter state cb1",                 //
                "interrupt do-action-in-state-c",  // <- myEvent 1
                "exit do-action-in-state-c",       //
                "exit state cb1",                  //
                "exit state cb2",                  //
                "exit state c",                    //
                "enter state a"                    //
        );

        Assert.assertEquals(expectedEvtList,actualEvtList);
    }

    @Test
    public void nestedOrthogonalWithDoActionAsyncTest() throws InterruptedException {

        var actualEvtList = new ArrayList<String>();

        FSM fsm = createNestedWithOrthogonal(actualEvtList);

        Executor executor = Executor.newInstance(fsm);
        executor.startAsync();

        executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        //executor.process("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));


        Thread.sleep(15000);

        var expectedEvtList = Arrays.asList(
                "enter state a",               // <- fsm:init
                "exit state a",                // <- myEvent 1
                "enter state b",               //
                "exit state b",                // <- myEvent 2
                "enter state c",               //
                "enter do-action-in-state-c",  //
                "enter state ca1",             //
                "enter state ca2",             //
                "exit state ca2",              // <- myEvent 2
                "enter state cb2",             //
                "exit state ca1",              // <- myEvent 1
                "enter state cb1",             //
                "exit do-action-in-state-c",   // <- timeout (sleep)
                "exit state cb1",              // <- fsm:on-do-action-done
                "exit state cb2",              //
                "exit state c",                //
                "enter state a"                //
        );

        Assert.assertEquals(expectedEvtList,actualEvtList);

    }

    @Test
    public void nestedOrthogonalWithDoActionInterruptAsyncTest() throws InterruptedException {

        var actualEvtList = new ArrayList<String>();

        FSM fsm = createNestedWithOrthogonal(actualEvtList);

        Executor executor = Executor.newInstance(fsm);
        executor.startAsync();

        executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
        executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));


        Thread.sleep(1000);

        var expectedEvtList = Arrays.asList(
                "enter state a",                   // <- fsm:init
                "exit state a",                    // <- myEvent 1
                "enter state b",                   //
                "exit state b",                    // <- myEvent 2
                "enter state c",                   //
                "enter do-action-in-state-c",      //
                "enter state ca1",                 //
                "enter state ca2",                 //
                "exit state ca2",                  // <- myEvent 2
                "enter state cb2",                 //
                "exit state ca1",                  // <- myEvent 1
                "enter state cb1",                 //
                "interrupt do-action-in-state-c",  // <- myEvent 1
                "exit do-action-in-state-c",       //
                "exit state cb1",                  //
                "exit state cb2",                  //
                "exit state c",                    //
                "enter state a"                    //
        );

        Assert.assertEquals(expectedEvtList,actualEvtList);

    }

    private static FSM createNestedWithOrthogonal(List<String> enterExitList) {
        State stateA = State.newBuilder()
                .withName("State A")
                .withOnEntryAction((s, e) -> {System.out.println("enter state a");enterExitList.add("enter state a");})
//                .withDoAction()
                .withOnExitAction((s, e) -> {System.out.println("exit state a");enterExitList.add("exit state a");})
                .build();
        State stateB = State.newBuilder()
                .withName("State B")
                .withOnEntryAction((s, e) -> {System.out.println("enter state b");enterExitList.add("enter state b");})
//                .withDoAction()
                .withOnExitAction((s, e) -> {System.out.println("exit state b");enterExitList.add("exit state b");})
                .build();

        State stateCA1 = State.newBuilder()
                .withName("State CA1")
                .withOnEntryAction((s, e) -> {System.out.println("  enter state ca1");enterExitList.add("enter state ca1");})
//                .withDoAction()
                .withOnExitAction((s, e) -> {System.out.println("  exit state ca1");enterExitList.add("exit state ca1");})
                .build();

        State stateCB1 = State.newBuilder()
                .withName("State CB1")
                .withOnEntryAction((s, e) -> {System.out.println("  enter state cb1");enterExitList.add("enter state cb1");})
//                .withDoAction()
                .withOnExitAction((s, e) -> {System.out.println("  exit state cb1");enterExitList.add("exit state cb1");})
                .build();

        State stateCA2 = State.newBuilder()
                .withName("State CA2")
                .withOnEntryAction((s, e) -> {System.out.println("  enter state ca2");enterExitList.add("enter state ca2");})
//                .withDoAction()
                .withOnExitAction((s, e) -> {System.out.println("  exit state ca2");enterExitList.add("exit state ca2");})
                .build();

        State stateCB2 = State.newBuilder()
                .withName("State CB2")
                .withOnEntryAction((s, e) -> {System.out.println("  enter state cb2");enterExitList.add("enter state cb2");})
//                .withDoAction()
                .withOnExitAction((s, e) -> {System.out.println("  exit state cb2");enterExitList.add("exit state cb2");})
                .build();


        FSMState stateC = FSMState.newBuilder()
                .withName("State C")
                .withOnEntryAction((s, e) -> {System.out.println("enter state c");enterExitList.add("enter state c");})
                .withOnExitAction((s, e) -> {System.out.println("exit state c");enterExitList.add("exit state c");})
                .withDoAction((s, e) -> {
                    try {
                        System.out.println("enter do-action-in-state-c");
                        enterExitList.add("enter do-action-in-state-c");
                        Thread.sleep(10000);
                    } catch (InterruptedException interruptedException) {
                        System.out.println("interrupt do-action-in-state-c");
                        enterExitList.add("interrupt do-action-in-state-c");
                        Thread.currentThread().interrupt();
                    } finally {
                        System.out.println("exit do-action-in-state-c");
                        enterExitList.add("exit do-action-in-state-c");
                    }
                })
                .withFSMs(
                        FSM.newBuilder()
                                .withName("FSM C1")
//                                .withVerbose(true)
                                .withOwnedState(stateCA1, stateCB1)
                                .withInitialState(stateCA1)
                                .withFinalState(stateCB1)
                                .withTransitions(
                                        Transition.newBuilder()
                                                .withSource(stateCA1)
                                                .withTarget(stateCB1)
                                                .withTrigger("myEvent1")
                                                .build()
                                )
                                .build(),
                        FSM.newBuilder()
                                .withName("FSM C2")
//                                .withVerbose(true)
                                .withOwnedState(stateCA2, stateCB2)
                                .withInitialState(stateCA2)
                                .withFinalState(stateCB2)
                                .withTransitions(
                                        Transition.newBuilder()
                                                .withSource(stateCA2)
                                                .withTarget(stateCB2)
                                                .withTrigger("myEvent2")
                                                .build()
                                )
                                .build()
                )
                .build();

        FSM fsm = FSM.newBuilder()
                .withName("FSM")
                .withVerbose(true)
                .withInitialState(stateA)
                .withOwnedState(stateA,stateB,stateC)
                .withTransitions(
                        Transition.newBuilder()
                                .withSource(stateA)
                                .withTarget(stateB)
                                .withTrigger("myEvent1")
                                .build(),
                        Transition.newBuilder()
                                .withSource(stateB)
                                .withTarget(stateC)
                                .withTrigger("myEvent2")
                                .build(),
                        Transition.newBuilder()
                                .withSource(stateC)
                                .withTarget(stateA)
                                .withTrigger("myEvent1")
                                .build()
                        ,
                        Transition.newBuilder()
                                .withSource(stateC)
                                .withTarget(stateA)
                                .withTrigger("fsm:on-do-action-done")
                                .build()
                )
                .build();

        return fsm;
    }

    @Test
    public void enterNestedStateDirectlyTest() {

        var actualEvtList = new ArrayList<String>();

        FSM fsm_a = FSM.newBuilder()
                .withName("FSM a")
                .build();

        FSM fsm_a_a = FSM.newBuilder()
                .withName("FSM a_a")
                .build();

        FSM fsm_a_b = FSM.newBuilder()
                .withName("FSM a_b")
                .build();

        State state_a = FSMState.newBuilder()
                .withName("a")
                .withOnEntryAction((s,e)->actualEvtList.add("enter state a"))
                .withOnExitAction((s,e)->actualEvtList.add("exit state a"))
                .withFSMs(fsm_a)
                .build();

        State state_a_a = FSMState.newBuilder()
                .withName("a_a")
                .withOnEntryAction((s,e)->actualEvtList.add("enter state a_a"))
                .withOnExitAction((s,e)->actualEvtList.add("exit state a_a"))
                .withFSMs(fsm_a_a)
                .build();

        State state_a_a_a = State.newBuilder()
                .withName("a_a_a")
                .withOnEntryAction((s,e)->actualEvtList.add("enter state a_a_a"))
                .withOnExitAction((s,e)->actualEvtList.add("exit state a_a_a"))
                .build();

        State state_a_b = FSMState.newBuilder()
                .withName("a_b")
                .withOnEntryAction((s,e)->actualEvtList.add("enter state a_b"))
                .withOnExitAction((s,e)->actualEvtList.add("exit state a_b"))
                .withFSMs(fsm_a_b)
                .build();

        fsm_a.getOwnedState().add(state_a_a);
        fsm_a.getOwnedState().add(state_a_b);
        fsm_a.setInitialState(state_a_a);

        fsm_a_a.getOwnedState().add(state_a_a_a);
        fsm_a_a.setInitialState(state_a_a_a);

        State state_a_b_a = State.newBuilder()
                .withName("a_b_a")
                .withOnEntryAction((s,e)->actualEvtList.add("enter state a_b_a"))
                .withOnExitAction((s,e)->actualEvtList.add("exit state a_b_a"))
                .build();

        Transition a_a__a_b_a = Transition.newBuilder()
                .withTrigger("myEvent1")
                .withSource(state_a_a_a)
                .withTarget(state_a_b_a)
                .build();

        fsm_a.getTransitions().add(a_a__a_b_a);

        fsm_a_b.getOwnedState().add(state_a_b_a);
        fsm_a_b.setInitialState(state_a_b_a);

        FSM fsm = FSM.newBuilder()
                .withOwnedState(state_a)
                .withInitialState(state_a)
                .build();

        Executor executor = Executor.newInstance(fsm);
        fsm.setRunning(true);
        executor.process("myEvent1");
        fsm.setRunning(false);


        var expectedEvtList = Arrays.asList(
                "enter state a",                    // <- fsm:init
                "enter state a_a",                  //
                "enter state a_a_a",                //
                "exit state a_a_a",                 // <- myEvent1
                "exit state a_a",                   //
                "enter state a_b",                  //
                "enter state a_b_a"                 //
        );

        Assert.assertEquals(expectedEvtList,actualEvtList);

    }
}
