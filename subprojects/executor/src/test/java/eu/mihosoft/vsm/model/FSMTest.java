/*
 * Copyright 2019-2021 Michael Hoffer <info@michaelhoffer.de>. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * If you use this software for scientific research then please cite the following publication(s):
 *
 * M. Hoffer, C. Poliwoda, & G. Wittum. (2013). Visual reflection library:
 * a framework for declarative GUI programming on the Java platform.
 * Computing and Visualization in Science, 2013, 16(4),
 * 181â€“192. http://doi.org/10.1007/s00791-014-0230-y
 */
/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package eu.mihosoft.vsm.model;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

import eu.mihosoft.vsm.executor.Executor;
import org.junit.Assert;
import org.junit.Rule;
import org.junit.Test;

import java.lang.management.ManagementFactory;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

public class FSMTest {

    private static final eu.mihosoft.vsm.model.AsyncExecutor.ExecutionMode MODE
            = eu.mihosoft.vsm.model.AsyncExecutor.ExecutionMode.PARALLEL_REGIONS;

    private static final int NUM_ITERATIONS_LARGE_TESTS = 25;
    private static final int NUM_ITERATIONS_SMALL_TESTS = 100;

    static boolean sleepRandom(long min, long max) {
        long duration = ThreadLocalRandom.current().nextLong(max - min + 1) + min;
        try {
            Thread.sleep(duration);
            return true;
        } catch (InterruptedException e) {
            e.printStackTrace();
            return false;
        }
    }

    @Test public void testATMFSM() throws InterruptedException {

        for(int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            State idleState = State.newBuilder().withName("idle").withOnEntryAction(
                    (s, e) -> {
                        System.out.println("Machine Idle State");
                    }).build();

            State cardInserted = State.newBuilder().withName("cardInserted")
                    .withOnEntryAction((s, e) -> {
                        System.out.println("Card Inserted State");
                    }).build();

            State pinEnteredState = State.newBuilder().withName("pinEntered")
                    .withOnEntryAction((s, e) -> {
                        System.out.println("Pin Entered State");
                    }).build();

            State amountRequested = State.newBuilder().withName("amountRequested")
                    .withOnEntryAction((s, e) -> {
                        System.out.println("Amount Requested State");
                    }).build();

            Transition insertCardTransition = Transition.newBuilder().withTrigger("insert-card")
                    .withGuard((t, evt) -> {
                        if (evt.getArgs().isEmpty()) return false;
                        return Objects.equals("DE6594339437", evt.getArgs().get(0));
                    })
                    .withActions((s, e) -> {
                        System.out.println("-> correct card inserted");
                    }).withSource(idleState).withTarget(cardInserted).build();

            Transition enterPinTransition = Transition.newBuilder().withTrigger("enter-pin")
                    .withGuard((t, evt) -> {
                        System.out.println("-> pin entered");
                        System.out.println("-> checking...");

                        sleepRandom(0,250);

                        if (evt.getArgs().isEmpty()) {
                            return false;
                        }

                        return Objects.equals(1234, evt.getArgs().get(0));
                    }).withActions((s, e) -> {
                        System.out.println("-> valid.");
                    }).withSource(cardInserted).withTarget(pinEnteredState).build();

            Transition requestAmountTransition = Transition.newBuilder().withTrigger("request-amount")
                    .withActions((s, e) -> {
                        System.out.println("-> amount-requested");
                    }).withSource(pinEnteredState).withTarget(amountRequested).build();

            Transition moneyDispatchedTransition = Transition.newBuilder().withTrigger("dispatch-money")
                    .withActions((s, e) -> {
                        System.out.println("-> checking whether requested amount is available");
                        sleepRandom(0,80);
                        System.out.println("-> money-dispatched");
                    })
                    .withSource(amountRequested)
                    .withTarget(idleState)
                    .build();

            State errorState = State.newBuilder()
                    .withName("Error")
                    .withOnEntryAction((state, event) -> {
                        System.out.println("ERROR: ");
                    })
                    .build();

            FSM fsm = FSM.newBuilder()
                    .withName("ATM")
                    .withOwnedState(
                            idleState, cardInserted, pinEnteredState, amountRequested, errorState
                    )
                    .withInitialState(idleState)
                    .withErrorState(errorState)
                    .withTransitions(
                            insertCardTransition,
                            enterPinTransition,
                            requestAmountTransition,
                            moneyDispatchedTransition
                    )
                    .withVerbose(true)
                    .build();

            var visitedStates = Collections.synchronizedList(new ArrayList<State>());

            fsm.vmf().reflect().propertyByName("currentState").orElseThrow().addChangeListener(change -> {
                var oldV = (State) change.propertyChange().orElseThrow().oldValue();
                var newV = (State) change.propertyChange().orElseThrow().newValue();
                System.out.println(Thread.currentThread() + " > transitioned from " +
                        (oldV == null ? "<undefined>" : oldV.getName()) +
                        " to " +
                        (newV == null ? "<undefined>" : newV.getName()));
                if (newV != null) {
                    visitedStates.add(newV);
                }
            });

            Executor executor = Executor.newInstance(fsm, MODE);

            executor.startAsync();

            sleepRandom(0,2500);

            executor.trigger("insert-card", "DE6594339437");

            sleepRandom(0,250);

            executor.trigger("enter-pin", 1234);

            sleepRandom(0,350);

            executor.trigger("request-amount", 35);

            var f = new CompletableFuture();
            executor.trigger("dispatch-money",(e, t) -> {f.complete(null);} , 35);

            // wait until last event is consumed
            f.orTimeout(10000, TimeUnit.MILLISECONDS).join();

            executor.stop();

            System.out.println("> Visited States: "
                    + visitedStates.stream().map(s -> s.getName()).
                    collect(Collectors.joining(", "))
            );

            System.out.println("> number of active threads: " + ManagementFactory.getThreadMXBean().getThreadCount());

            assertThat(visitedStates, contains(
                    idleState,
                    cardInserted,
                    pinEnteredState,
                    amountRequested,
                    idleState
                    )
            );

        }

    }

    @Test
    public void nestedOrthogonalWithDoActionProcessingTest() throws InterruptedException {

        for(int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            System.out.println("-------------- nestedOrthogonalWithDoActionProcessingTest(), iteration: " + i);

            var actualEvtList = new ArrayList<String>();

            FSM fsm = createNestedWithOrthogonal(actualEvtList);

            Executor executor = Executor.newInstance(fsm, MODE);
//        executor.startAsync();
            fsm.setRunning(true);
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            //executor.process("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));

            while (executor.hasRemainingEvents()) {
                executor.processRemainingEvents();
            }

            if(MODE == eu.mihosoft.vsm.model.AsyncExecutor.ExecutionMode.PARALLEL_REGIONS) {

                Thread.sleep(100); // TODO (hasRemainingEvents() might still be buggy)

                while (executor.hasRemainingEvents()) {
                    executor.processRemainingEvents();
                }
            }


            fsm.setRunning(false);

            var expectedEvtList = Arrays.asList(
                    "enter state a",               // <- fsm:init
                    "exit state a",                // <- myEvent 1
                    "enter state b",               //
                    "exit state b",                // <- myEvent 2
                    "enter state c",               //
//                "enter do-action-in-state-c",  // test without enter do-action-in-state-c, because position may vary
                    "enter state ca1",             //
                    "enter state ca2",             //
                    "exit state ca2",              // <- myEvent 2
                    "enter state cb2",             //
                    "exit state cb2",              // (fsm reached final state)
                    "exit state ca1",              // <- myEvent 1
                    "enter state cb1",             //
                    "exit state cb1",              // (fsm reached final state)
                    "exit do-action-in-state-c",   // <- timeout (sleep)
                    "exit state c",                //
                    "enter state a"                //
            );

            // test without enter do-action-in-state-c, because position may vary
            actualEvtList.remove("enter do-action-in-state-c");

            // A better way to verify correct execution is to trace child FSMs aka regions individually.
            // But in this configuration we cannot test for a specific sequence.
            Assert.assertEquals(expectedEvtList.size(), actualEvtList.size());
        }
    }

    @Test
    public void nestedOrthogonalWithDoActionInterruptedProcessingTest() {

        for(int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            var actualEvtList = new ArrayList<String>();

            FSM fsm = createNestedWithOrthogonal(actualEvtList);

            Executor executor = Executor.newInstance(fsm, MODE);

            fsm.setRunning(true);
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));

            while (executor.hasRemainingEvents()) {
                executor.processRemainingEvents();
            }

            fsm.setRunning(false);

            var expectedEvtList = Arrays.asList(
                    "enter state a",                   // <- fsm:init
                    "exit state a",                    // <- myEvent 1
                    "enter state b",                   //
                    "exit state b",                    // <- myEvent 2
                    "enter state c",                   //
//                "enter do-action-in-state-c",      // test without enter do-action-in-state-c, because position may vary
                    "enter state ca1",                 //
                    "enter state ca2",                 //
                    "exit state ca2",                  // <- myEvent 2
                    "enter state cb2",                 //
                    "exit state cb2",                  // (fsm reached final state)
                    "exit state ca1",                  // <- myEvent 1
                    "enter state cb1",                 //
                    "exit state cb1",                  // (fsm reached final state)
                    "interrupt do-action-in-state-c",  // <- myEvent 1
                    "exit do-action-in-state-c",       //
                    "exit state c",                    //
                    "enter state a"                    //
            );

            // test without enter do-action-in-state-c, because position may vary
            actualEvtList.remove("enter do-action-in-state-c");

            // A better way to verify correct execution is to trace child FSMs aka regions individually.
            // But in this configuration we cannot test for a specific sequence.
            Assert.assertEquals(expectedEvtList.size(), actualEvtList.size());
        }
    }

    @Test
    public void nestedOrthogonalWithDoActionAsyncTest() throws InterruptedException {

        for(int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            var actualEvtList = new ArrayList<String>();

            FSM fsm = createNestedWithOrthogonal(actualEvtList);

            Executor executor = Executor.newInstance(fsm, MODE);
            executor.startAsync();

            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            //executor.process("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));

            Thread.sleep(1500);

            executor.stop();

            var expectedEvtList = Arrays.asList(
                    "enter state a",               // <- fsm:init
                    "exit state a",                // <- myEvent 1
                    "enter state b",               //
                    "exit state b",                // <- myEvent 2
                    "enter state c",               //
//                "enter do-action-in-state-c",  // test without enter do-action-in-state-c, because position may vary
                    "enter state ca1",             //
                    "enter state ca2",             //
                    "exit state ca2",              // <- myEvent 2
                    "enter state cb2",             //
                    "exit state cb2",              // (fsm reached final state)
                    "exit state ca1",              // <- myEvent 1
                    "enter state cb1",             //
                    "exit state cb1",              // (fsm reached final state)
                    "exit do-action-in-state-c",   // <- timeout (sleep)
                    "exit state c",                //
                    "enter state a"                //
            );

            // test without enter do-action-in-state-c, because position may vary
            actualEvtList.remove("enter do-action-in-state-c");

            System.out.println("---------------------------------");
            System.out.println(actualEvtList);

            // A better way to verify correct execution is to trace child FSMs aka regions individually.
            // But in this configuration we cannot test for a specific sequence.
            Assert.assertEquals(expectedEvtList.size(), actualEvtList.size());
        }
    }

    @Test
    public void nestedOrthogonalWithDoActionInterruptAsyncTest() throws InterruptedException {

        for(int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            var actualEvtList = new ArrayList<String>();

            FSM fsm = createNestedWithOrthogonal(actualEvtList);

            Executor executor = Executor.newInstance(fsm, MODE);
            executor.startAsync();

            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent2", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));
            executor.trigger("myEvent1", (e, t) -> System.out.println("consumed " + e.getName() + ", " + t.getOwningFSM().getName()));


            Thread.sleep(200);
            executor.stop();

            var expectedEvtList = Arrays.asList(
                    "enter state a",                   // <- fsm:init
                    "exit state a",                    // <- myEvent 1
                    "enter state b",                   //
                    "exit state b",                    // <- myEvent 2
                    "enter state c",                   //
//                "enter do-action-in-state-c",      // test without enter do-action-in-state-c, because position may vary
                    "enter state ca1",                 //
                    "enter state ca2",                 //
                    "exit state ca2",                  // <- myEvent 2
                    "enter state cb2",                 //
                    "exit state cb2",                  // (fsm reached final state)
                    "exit state ca1",                  // <- myEvent 1
                    "enter state cb1",                 //
                    "exit state cb1",                  // (fsm reached final state)
                    "interrupt do-action-in-state-c",  // <- myEvent 1
                    "exit do-action-in-state-c",       //
                    "exit state c",                    //
                    "enter state a"                    //
            );

            // test without enter do-action-in-state-c, because position may vary
            actualEvtList.remove("enter do-action-in-state-c");

            // A better way to verify correct execution is to trace child FSMs aka regions individually.
            // But in this configuration we cannot test for a specific sequence.
            Assert.assertEquals(expectedEvtList.size(), actualEvtList.size());
        }
    }

    private static FSM createNestedWithOrthogonal(List<String> enterExitListOrig) {

        final var enterExitList = Collections.synchronizedList(enterExitListOrig);

        State stateA = State.newBuilder()
                .withName("State A")
                .withOnEntryAction((s, e) -> {System.out.println("enter state a");enterExitList.add("enter state a");})
//                .withDoAction()
                .withOnExitAction((s, e) -> {System.out.println("exit state a");enterExitList.add("exit state a");})
                .build();
        State stateB = State.newBuilder()
                .withName("State B")
                .withOnEntryAction((s, e) -> {System.out.println("enter state b");enterExitList.add("enter state b");})
//                .withDoAction()
                .withOnExitAction((s, e) -> {System.out.println("exit state b");enterExitList.add("exit state b");})
                .build();

        State stateCA1 = State.newBuilder()
                .withName("State CA1")
                .withOnEntryAction((s, e) -> {System.out.println("  enter state ca1");enterExitList.add("enter state ca1");})
//                .withDoAction()
                .withOnExitAction((s, e) -> {System.out.println("  exit state ca1");enterExitList.add("exit state ca1");})
                .build();

        State stateCB1 = State.newBuilder()
                .withName("State CB1")
                .withOnEntryAction((s, e) -> {System.out.println("  enter state cb1");enterExitList.add("enter state cb1");})
//                .withDoAction()
                .withOnExitAction((s, e) -> {System.out.println("  exit state cb1");enterExitList.add("exit state cb1");})
                .build();

        State stateCA2 = State.newBuilder()
                .withName("State CA2")
                .withOnEntryAction((s, e) -> {System.out.println("  enter state ca2");enterExitList.add("enter state ca2");})
//                .withDoAction()
                .withOnExitAction((s, e) -> {System.out.println("  exit state ca2");enterExitList.add("exit state ca2");})
                .build();

        State stateCB2 = State.newBuilder()
                .withName("State CB2")
                .withOnEntryAction((s, e) -> {System.out.println("  enter state cb2");enterExitList.add("enter state cb2");})
//                .withDoAction()
                .withOnExitAction((s, e) -> {System.out.println("  exit state cb2");enterExitList.add("exit state cb2");})
                .build();


        FSMState stateC = FSMState.newBuilder()
                .withName("State C")
                .withOnEntryAction((s, e) -> {System.out.println("enter state c");enterExitList.add("enter state c");})
                .withOnExitAction((s, e) -> {System.out.println("exit state c");enterExitList.add("exit state c");})
                .withDoAction((s, e) -> {
                    try {
                        System.out.println("enter do-action-in-state-c");
                        enterExitList.add("enter do-action-in-state-c");
                        Thread.sleep(1000);
                    } catch (InterruptedException interruptedException) {
                        System.out.println("interrupt do-action-in-state-c");
                        enterExitList.add("interrupt do-action-in-state-c");
                        Thread.currentThread().interrupt();
                    } finally {
                        System.out.println("exit do-action-in-state-c");
                        enterExitList.add("exit do-action-in-state-c");
                    }
                })
                .withFSMs(
                        FSM.newBuilder()
                                .withName("FSM C1")
//                                .withVerbose(true)
                                .withOwnedState(stateCA1, stateCB1)
                                .withInitialState(stateCA1)
                                .withFinalState(stateCB1)
                                .withTransitions(
                                        Transition.newBuilder()
                                                .withSource(stateCA1)
                                                .withTarget(stateCB1)
                                                .withTrigger("myEvent1")
                                                .build()
                                )
                                .build(),
                        FSM.newBuilder()
                                .withName("FSM C2")
//                                .withVerbose(true)
                                .withOwnedState(stateCA2, stateCB2)
                                .withInitialState(stateCA2)
                                .withFinalState(stateCB2)
                                .withTransitions(
                                        Transition.newBuilder()
                                                .withSource(stateCA2)
                                                .withTarget(stateCB2)
                                                .withTrigger("myEvent2")
                                                .build()
                                )
                                .build()
                )
                .build();

        FSM fsm = FSM.newBuilder()
                .withName("FSM")
                .withVerbose(true)
                .withInitialState(stateA)
                .withOwnedState(stateA,stateB,stateC)
                .withTransitions(
                        Transition.newBuilder()
                                .withSource(stateA)
                                .withTarget(stateB)
                                .withTrigger("myEvent1")
                                .build(),
                        Transition.newBuilder()
                                .withSource(stateB)
                                .withTarget(stateC)
                                .withTrigger("myEvent2")
                                .build(),
                        Transition.newBuilder()
                                .withSource(stateC)
                                .withTarget(stateA)
                                .withTrigger("myEvent1")
                                .build()
                        ,
                        Transition.newBuilder()
                                .withSource(stateC)
                                .withTarget(stateA)
                                .withTrigger(eu.mihosoft.vsm.model.Executor.FSMEvents.DO_ACTION_DONE.getName())
                                .build()
                )
                .build();

        return fsm;
    }

    @Test
    public void enterNestedStateDirectlyTest() throws InterruptedException {

        for(int i = 0; i < NUM_ITERATIONS_SMALL_TESTS; i++) {

            var actualEvtList = new ArrayList<String>();

            FSM fsm_a = FSM.newBuilder()
                    .withName("FSM a")
                    .build();

            FSM fsm_a_a = FSM.newBuilder()
                    .withName("FSM a_a")
                    .build();

            FSM fsm_a_b = FSM.newBuilder()
                    .withName("FSM a_b")
                    .build();

            State state_a = FSMState.newBuilder()
                    .withName("a")
                    .withOnEntryAction((s, e) -> actualEvtList.add("enter state a"))
                    .withOnExitAction((s, e) -> actualEvtList.add("exit state a"))
                    .withFSMs(fsm_a)
                    .build();

            State state_a_a = FSMState.newBuilder()
                    .withName("a_a")
                    .withOnEntryAction((s, e) -> actualEvtList.add("enter state a_a"))
                    .withOnExitAction((s, e) -> actualEvtList.add("exit state a_a"))
                    .withFSMs(fsm_a_a)
                    .build();

            State state_a_a_a = State.newBuilder()
                    .withName("a_a_a")
                    .withOnEntryAction((s, e) -> actualEvtList.add("enter state a_a_a"))
                    .withOnExitAction((s, e) -> actualEvtList.add("exit state a_a_a"))
                    .build();

            State state_a_b = FSMState.newBuilder()
                    .withName("a_b")
                    .withOnEntryAction((s, e) -> actualEvtList.add("enter state a_b"))
                    .withOnExitAction((s, e) -> actualEvtList.add("exit state a_b"))
                    .withFSMs(fsm_a_b)
                    .build();

            fsm_a.getOwnedState().add(state_a_a);
            fsm_a.getOwnedState().add(state_a_b);
            fsm_a.setInitialState(state_a_a);

            fsm_a_a.getOwnedState().add(state_a_a_a);
            fsm_a_a.setInitialState(state_a_a_a);

            State state_a_b_a = State.newBuilder()
                    .withName("a_b_a")
                    .withOnEntryAction((s, e) -> actualEvtList.add("enter state a_b_a"))
                    .withOnExitAction((s, e) -> actualEvtList.add("exit state a_b_a"))
                    .build();

            Transition a_a__a_b_a = Transition.newBuilder()
                    .withTrigger("myEvent1")
                    .withSource(state_a_a_a)
                    .withTarget(state_a_b_a)
                    .build();

            fsm_a_b.getOwnedState().add(state_a_b_a);
            fsm_a_b.setInitialState(state_a_b_a);

            FSM fsm = FSM.newBuilder()
                    .withOwnedState(state_a)
                    .withInitialState(state_a)
                    .build();

            fsm.getTransitions().add(a_a__a_b_a);

            Executor executor = Executor.newInstance(fsm, MODE);
            fsm.setRunning(true);
            executor.process("myEvent1");
            fsm.setRunning(false);

            var expectedEvtList = Arrays.asList(
                    "enter state a",                    // <- fsm:init
                    "enter state a_a",                  //
                    "enter state a_a_a",                //
                    "exit state a_a_a",                 // <- myEvent1
                    "exit state a_a",                   //
                    "enter state a_b",                  //
                    "enter state a_b_a"                 //
            );

            Assert.assertEquals(expectedEvtList, actualEvtList);

        } // end for i

    }

    @Test
    public void lockedDoorTest() throws InterruptedException {

        var actualEvtList = new ArrayList<String>();

        String event_close  = "close";
        String event_open   = "open";
        String event_lock   = "lock";
        String event_unlock = "unlock";

        State opened = State.newBuilder()
                .withName("opened")
                .withOnEntryAction((s,e)->{
                    actualEvtList.add("enter opened");
                })
                .withOnExitAction((s,e)->actualEvtList.add("exit opened"))
                .build();

        State closed = State.newBuilder()
                .withName("closed")
                .withOnEntryAction((s,e)->actualEvtList.add("enter closed"))
                .withOnExitAction((s,e)->actualEvtList.add("exit closed"))
                .build();

        State locked = State.newBuilder()
                .withName("locked")
                .withOnEntryAction((s,e)->actualEvtList.add("enter locked"))
                .withOnExitAction((s,e)->actualEvtList.add("exit locked"))
                .build();


        Transition closeDoor = Transition.newBuilder()
                .withTrigger(event_close)
                .withSource(opened)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("closeDoor(), evt: " + e.getName());
                    actualEvtList.add("closeDoor()");
                })
                .build();

        Transition openDoor = Transition.newBuilder()
                .withTrigger(event_open)
                .withSource(closed)
                .withTarget(opened)
                .withActions((t, e) -> {
                    System.out.println("openDoor(), evt: " + e.getName());
                    actualEvtList.add("openDoor()");
                })
                .build();

        Transition lockDoor = Transition.newBuilder()
                .withTrigger(event_lock)
                .withSource(closed)
                .withTarget(locked)
                .withActions((t, e) -> {
                    System.out.println("lockDoor(), evt: " + e.getName());
                    actualEvtList.add("lockDoor()");
                })
                .build();

        Transition unlockDoor = Transition.newBuilder()
                .withTrigger(event_unlock)
                .withSource(locked)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("unlockDoor(), evt: " + e.getName());
                    actualEvtList.add("unlockDoor()");
                })
                .build();

        FSM fsm = FSM.newBuilder()
                .withInitialState(opened)
                .withOwnedState(opened,closed,locked)
                .withTransitions(openDoor,closeDoor,lockDoor,unlockDoor)
                .build();

        Executor executor = Executor.newInstance(fsm, MODE);

        fsm.setRunning(true);

        executor.process(event_close);
        executor.process(event_lock);
        executor.process(event_unlock);
        executor.process(event_open);

        executor.process(event_lock); // try invalid
        executor.process(event_close);
        executor.process(event_lock);

        executor.process(event_open); // try invalid

        fsm.setRunning(false);

        var expectedEvtList = Arrays.asList(
                "enter opened",  // <- fsm:init

                "exit opened",
                "closeDoor()",
                "enter closed",

                "exit closed",
                "lockDoor()",
                "enter locked",

                "exit locked",
                "unlockDoor()",
                "enter closed",

                "exit closed",
                "openDoor()",
                "enter opened",

                // not "lockDoor()" because it's invalid

                "exit opened",
                "closeDoor()",
                "enter closed",

                "exit closed",
                "lockDoor()",
                "enter locked"

                // not "openDoor()" because it's invalid
        );

        Assert.assertEquals(expectedEvtList,actualEvtList);

    }

    @Test
    public void lockedDoorWithLockVariableAndLocalTransitionTest() throws InterruptedException {

        var actualEvtList = new ArrayList<String>();

        String event_close  = "close";
        String event_open   = "open";
        String event_lock   = "lock";
        String event_unlock = "unlock";

        AtomicBoolean lockedState = new AtomicBoolean();

        State opened = State.newBuilder()
                .withName("opened")
                .withOnEntryAction((s,e)->{
                    actualEvtList.add("enter opened");
                })
                .withOnExitAction((s,e)->actualEvtList.add("exit opened"))
                .build();

        State closed = State.newBuilder()
                .withName("closed")
                .withOnEntryAction((s,e)->actualEvtList.add("enter closed"))
                .withOnExitAction((s,e)->actualEvtList.add("exit closed"))
                .build();


        Transition closeDoor = Transition.newBuilder()
                .withTrigger(event_close)
                .withSource(opened)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("closeDoor(), evt: " + e.getName());
                    actualEvtList.add("closeDoor()");
                })
                .build();

        Transition openDoor = Transition.newBuilder()
                .withTrigger(event_open)
                .withSource(closed)
                .withTarget(opened)
                .withGuard((transition, event) -> !lockedState.get())
                .withActions((t, e) -> {
                    System.out.println("openDoor(), evt: " + e.getName());
                    actualEvtList.add("openDoor()");
                })
                .build();

        Transition lockDoor = Transition.newBuilder()
                .withLocal(true)
                .withTrigger(event_lock)
                .withSource(closed)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("lockDoor(), evt: " + e.getName());
                    actualEvtList.add("lockDoor()");
                    lockedState.set(true);
                })
                .build();

        Transition unlockDoor = Transition.newBuilder()
                .withLocal(true)
                .withTrigger(event_unlock)
                .withSource(closed)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("unlockDoor(), evt: " + e.getName());
                    actualEvtList.add("unlockDoor()");
                    lockedState.set(false);
                })
                .build();

        FSM fsm = FSM.newBuilder()
                .withInitialState(opened)
                .withOwnedState(opened,closed)
                .withTransitions(openDoor,closeDoor,lockDoor,unlockDoor)
                .build();

        Executor executor = Executor.newInstance(fsm, MODE);

        fsm.setRunning(true);

        executor.process(event_close);
        executor.process(event_lock);
        executor.process(event_unlock);
        executor.process(event_open);

        executor.process(event_lock); // try invalid
        executor.process(event_close);
        executor.process(event_lock);

        executor.process(event_open); // try invalid

        fsm.setRunning(false);

        var expectedEvtList = Arrays.asList(
                "enter opened",  // <- fsm:init

                "exit opened",
                "closeDoor()",
                "enter closed",

//                "exit closed",  // self, deactivated due to local transitions (no enter and exit)
                "lockDoor()",
//                "enter closed", // self, deactivated due to local transitions (no enter and exit)


//                "exit closed",  // self, deactivated due to local transitions (no enter and exit)
                "unlockDoor()",
//                "enter closed", // self, deactivated due to local transitions (no enter and exit)

                "exit closed",
                "openDoor()",
                "enter opened",

                // not "lockDoor()" because it's invalid

                "exit opened",
                "closeDoor()",
                "enter closed",

//                "exit closed"   // self, deactivated due to local transitions (no enter and exit)
                "lockDoor()"
//                "enter closed"  // self, deactivated due to local transitions (no enter and exit)

                // not "openDoor()" because it's invalid
        );

        Assert.assertEquals(expectedEvtList,actualEvtList);

    }

    @Test
    public void lockedDoorWithLockVariableTest() throws InterruptedException {

        var actualEvtList = new ArrayList<String>();

        String event_close  = "close";
        String event_open   = "open";
        String event_lock   = "lock";
        String event_unlock = "unlock";

        AtomicBoolean lockedState = new AtomicBoolean();

        State opened = State.newBuilder()
                .withName("opened")
                .withOnEntryAction((s,e)->{
                    actualEvtList.add("enter opened");
                })
                .withOnExitAction((s,e)->actualEvtList.add("exit opened"))
                .build();

        State closed = State.newBuilder()
                .withName("closed")
                .withOnEntryAction((s,e)->actualEvtList.add("enter closed"))
                .withOnExitAction((s,e)->actualEvtList.add("exit closed"))
                .build();


        Transition closeDoor = Transition.newBuilder()
                .withTrigger(event_close)
                .withSource(opened)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("closeDoor(), evt: " + e.getName());
                    actualEvtList.add("closeDoor()");
                })
                .build();

        Transition openDoor = Transition.newBuilder()
                .withTrigger(event_open)
                .withSource(closed)
                .withTarget(opened)
                .withGuard((transition, event) -> !lockedState.get())
                .withActions((t, e) -> {
                    System.out.println("openDoor(), evt: " + e.getName());
                    actualEvtList.add("openDoor()");
                })
                .build();

        Transition lockDoor = Transition.newBuilder()
                .withTrigger(event_lock)
                .withSource(closed)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("lockDoor(), evt: " + e.getName());
                    actualEvtList.add("lockDoor()");
                    lockedState.set(true);
                })
                .build();

        Transition unlockDoor = Transition.newBuilder()
                .withTrigger(event_unlock)
                .withSource(closed)
                .withTarget(closed)
                .withActions((t, e) -> {
                    System.out.println("unlockDoor(), evt: " + e.getName());
                    actualEvtList.add("unlockDoor()");
                    lockedState.set(false);
                })
                .build();

        FSM fsm = FSM.newBuilder()
                .withInitialState(opened)
                .withOwnedState(opened,closed)
                .withTransitions(openDoor,closeDoor,lockDoor,unlockDoor)
                .build();

        Executor executor = Executor.newInstance(fsm, MODE);

        fsm.setRunning(true);

        executor.process(event_close);
        executor.process(event_lock);
        executor.process(event_unlock);
        executor.process(event_open);

        executor.process(event_lock); // try invalid
        executor.process(event_close);
        executor.process(event_lock);

        executor.process(event_open); // try invalid

        fsm.setRunning(false);

        var expectedEvtList = Arrays.asList(
                "enter opened",  // <- fsm:init

                "exit opened",
                "closeDoor()",
                "enter closed",

                "exit closed",   // self
                "lockDoor()",
                "enter closed",  // self


                "exit closed",   // self
                "unlockDoor()",
                "enter closed",  // self

                "exit closed",
                "openDoor()",
                "enter opened",

                // not "lockDoor()" because it's invalid

                "exit opened",
                "closeDoor()",
                "enter closed",

                "exit closed",   // self
                "lockDoor()",
                "enter closed"   // self

                // not "openDoor()" because it's invalid
        );

        Assert.assertEquals(expectedEvtList,actualEvtList);

    }

//    @Test
//    public void localVsExternalTransitionTest() {
//        var actualEvtList = new ArrayList<String>();
//
//        StateAction entryAction = (s, e) -> {
//            actualEvtList.add("enter " + s.getName());
//        };
//
//        StateAction exitAction = (s, e) -> {
//            actualEvtList.add("exit " + s.getName());
//        };
//
//        State childState1 = State.newBuilder()
//                .withName("Child1")
//                .withOnEntryAction(entryAction)
//                .withOnExitAction(exitAction)
//                .build();
//
//        State childState2 = State.newBuilder()
//                .withName("Child2")
//                .withOnEntryAction(entryAction)
//                .withOnExitAction(exitAction)
//                .build();
//
//        State parentState = FSMState.newBuilder()
//                .withName("Parent")
//                .withOnEntryAction(entryAction)
//                .withOnExitAction(exitAction)
//                .withFSMs(FSM.newBuilder().withName("Nested FSM")
//                        .withInitialState(childState1)
//                        .withOwnedState(childState1, childState2)
//                        .build())
//                .build();
//
//        Transition t = Transition.newBuilder()
//                .withTrigger("event")
//                .withSource(parentState)
//                .withTarget(childState2)
//                .build();
//
//        FSM fsm = FSM.newBuilder()
//                .withInitialState(parentState)
//                .withOwnedState(parentState)
//                .withTransitions(t)
//                .build();
//
//        Executor executor = Executor.newInstance(fsm, MODE);
//
//        fsm.setRunning(true);
//        executor.process("event");
//        fsm.setRunning(false);
//
//        System.out.println(actualEvtList);
//
//        actualEvtList.clear();
//
//        t.setLocal(true);
//        fsm.setRunning(true);
//        executor.reset();
//        executor.process("event");
//        fsm.setRunning(false);
//
//        System.out.println(actualEvtList);
//
//    }

    @Test
    public void transitionPriorityTest1() throws InterruptedException, ExecutionException {

        for(int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            System.out.println("# ITERATIONS: " + i);

            {
                System.out.println("\nCase Priority to C2:");
                List<String> actualEvtList = new ArrayList<>();
                FSM fsm = createTransitionPriorityFSM(actualEvtList, true);
                Executor executor = Executor.newInstance(fsm, MODE);

                executor.startAsync();

                System.out.println("----> triggering event 1");
                executor.trigger("event1");
                System.out.println("----> triggering event 2");
                executor.trigger("event2");

                Thread.sleep(50);
                executor.stop();

                System.out.println("\nPriority to C2, FSM reactions: ");
                System.out.println(String.join("\n", actualEvtList));

                var expectedEvtList = Arrays.asList(
                        "enter s1",      // <- fsm:init

                        "exit s1",       // <- event1
                        "transitioning from s1 to parent, via event event1",
                        "enter parent",
                        "enter c1",

                        "exit c1",       // <- event2
                        "exit parent",
                        "transitioning from parent to c2, via event event2",
                        "enter parent",
                        "enter c2"
                );

                Assert.assertEquals(expectedEvtList, actualEvtList);
            }

            {
                System.out.println("\nCase Priority to S2:");
                List<String> actualEvtList = new ArrayList<>();
                FSM fsm = createTransitionPriorityFSM(actualEvtList, false);
                Executor executor = Executor.newInstance(fsm, MODE);

                executor.startAsync();

                System.out.println("----> triggering event 1");
                executor.trigger("event1");
                System.out.println("----> triggering event 2");
                executor.trigger("event2");

                Thread.sleep(50);
                executor.stop();

                System.out.println("\nFSM reactions: ");
                System.out.println(String.join("\n", actualEvtList));

                var expectedEvtList = Arrays.asList(
                        "enter s1",      // <- fsm:init

                        "exit s1",       // <- event1
                        "transitioning from s1 to parent, via event event1",
                        "enter parent",
                        "enter c1",

                        "exit c1",       // <- event2
                        "exit parent",
                        "transitioning from parent to s2, via event event2",
                        "enter s2"
                );

                Assert.assertEquals(expectedEvtList, actualEvtList);
            }

        } // end for i

    }

    private FSM createTransitionPriorityFSM(List<String> actualEvtListOrig, boolean parent_c2_first) {
        var actualEvtList = Collections.synchronizedList(actualEvtListOrig);

        StateAction entryAction = (s, e) -> {
            actualEvtList.add("enter " + s.getName());
        };

        StateAction exitAction = (s, e) -> {
            actualEvtList.add("exit " + s.getName());
        };

        TransitionAction transitioned = (t, e) -> {
            actualEvtList.add("transitioning from " + t.getSource().getName()
                    + " to " + t.getTarget().getName() + ", via event " + e.getName());
        };

        State c1 = State.newBuilder()
                .withName("c1")
                .withOnEntryAction(entryAction)
                .withOnExitAction(exitAction)
                .build();

        State c2 = State.newBuilder()
                .withName("c2")
                .withOnEntryAction(entryAction)
                .withOnExitAction(exitAction)
                .build();

        Transition c1_c2 = Transition.newBuilder()
                .withTrigger("event1")
                .withSource(c1)
                .withTarget(c2)
                .withActions(transitioned)
                .build();

        FSMState parent = FSMState.newBuilder()
                .withName("parent")
                .withOnEntryAction(entryAction)
                .withOnExitAction(exitAction)
                .withFSMs(FSM.newBuilder()
                        .withName("parent:r1")
                        .withOwnedState(c1, c2)
                        .withInitialState(c1)
                        .withTransitions(c1_c2)
                        .build()
                )
                .build();

        State s1 = State.newBuilder()
                .withName("s1")
                .withOnEntryAction(entryAction)
                .withOnExitAction(exitAction)
                .build();

        State s2 = State.newBuilder()
                .withName("s2")
                .withOnEntryAction(entryAction)
                .withOnExitAction(exitAction)
                .build();

        Transition s1_parent = Transition.newBuilder()
                .withSource(s1)
                .withTarget(parent)
                .withTrigger("event1")
                .withActions(transitioned)
                .build();

        Transition parent_s2 = Transition.newBuilder()
                .withSource(parent)
                .withTarget(s2)
                .withTrigger("event1")
                .withActions(transitioned)
                .build();

        Transition parent_c2 = Transition.newBuilder()
                .withTrigger("event2")
                .withActions(transitioned)
                .build();

        Transition parent_s2_b = Transition.newBuilder()
                .withTrigger("event2")
                .withActions(transitioned)
                .build();

        FSM fsm = FSM.newBuilder()
                .withName("fsm")
                .withOwnedState(parent, s1, s2)
                .withInitialState(s1)
                .withTransitions(s1_parent, parent_s2, parent_s2_b, parent_c2)
                .build();

        c2.getIncomingTransitions().add(parent_c2);
        s2.getIncomingTransitions().add(parent_s2_b);

        if (parent_c2_first) {
            parent.getOutgoingTransitions().add(parent_c2);
            parent.getOutgoingTransitions().add(parent_s2_b);
        } else {
            parent.getOutgoingTransitions().add(parent_s2_b);
            parent.getOutgoingTransitions().add(parent_c2);
        }

        return fsm;
    }

    @Test()
    public void testChildrenDoneEvent() throws InterruptedException {

        for (int i = 0; i < NUM_ITERATIONS_LARGE_TESTS; i++) {

            System.out.println("-------------- testChildrenDoneEvent(), iteration: " + i);

            List<String> actualEvtList = Collections.synchronizedList(new ArrayList<>());

            StateAction entryAction = (s, e) -> {
                actualEvtList.add("enter " + s.getName());
                System.out.println("enter " + s.getName());
            };

            StateAction exitAction = (s, e) -> {
                actualEvtList.add("exit " + s.getName());
                System.out.println("exit " + s.getName());
            };

            TransitionAction transitioned = (t, e) -> {
                actualEvtList.add("transitioning from " + t.getSource().getName()
                        + " to " + t.getTarget().getName() + ", via event " + e.getName());
                System.out.println("transitioning from " + t.getSource().getName()
                        + " to " + t.getTarget().getName() + ", via event " + e.getName());
            };

            State c1 = State.newBuilder()
                    .withName("c1")
                    .build();
            State c2 = State.newBuilder()
                    .withName("c2")
                    .build();

            Transition c1_c2 = Transition.newBuilder()
                    .withTrigger(eu.mihosoft.vsm.model.Executor.FSMEvents.STATE_DONE.getName())
                    .withSource(c1)
                    .withTarget(c2)
                    .build();

            FSM childFSM = FSM.newBuilder()
                    .withName("Child FSM")
                    .withInitialState(c1)
                    .withOwnedState(c1, c2)
                    .withFinalState(c2)
                    .withTransitions(c1_c2)
                    .build();

            FSM childFSM1 = childFSM.clone();
            childFSM1.setName("Child FSM 1");
//        childFSM1.setVerbose(true);
            childFSM1.getOwnedState().forEach(s -> s.setName(s.getName() + "-fsm1"));
            FSM childFSM2 = childFSM.clone();
            childFSM2.setName("Child FSM 2");
            childFSM2.getOwnedState().forEach(s -> s.setName(s.getName() + "-fsm2"));

            State s1 = State.newBuilder()
                    .withName("s1")
                    .build();

            AtomicBoolean childFSMStateWasInterrupted = new AtomicBoolean();

            FSMState childFSMState = FSMState.newBuilder()
                    .withName("ChildFSMState")
                    .withFSMs(childFSM1, childFSM2)
                    .withDoAction((s, e) -> {
                        try {
                            System.out.println("!!! cfsm: enter");
                            Thread.sleep(1500);
                            System.out.println("!!! cfsm: exit");
                        } catch (InterruptedException interruptedException) {
                            System.out.println("!!! cfsm: interrupted");
                            Thread.currentThread().interrupt();
                            childFSMStateWasInterrupted.set(true);
                        }
                    })
                    .build();

            AtomicBoolean s2WasInterrupted = new AtomicBoolean();

            State s2 = State.newBuilder()
                    .withName("s2")
                    .withDoAction((s, e) -> {
                        try {
                            System.out.println("!!! s2: enter");
                            Thread.sleep(150);
                            System.out.println("!!! s2: exit");
                        } catch (InterruptedException interruptedException) {
                            System.out.println("!!! s2: interrupt");
                            Thread.currentThread().interrupt();
                            s2WasInterrupted.set(true);
                        }
                    })
                    .build();

            State s3 = State.newBuilder()
                    .withName("s3")
                    .build();

            Transition s1_childFSMState = Transition.newBuilder()
                    .withTrigger(eu.mihosoft.vsm.model.Executor.FSMEvents.STATE_DONE.getName())
                    .withSource(s1)
                    .withTarget(childFSMState)
                    .build();

            Transition childFSMState_s2 = Transition.newBuilder()
                    .withTrigger(eu.mihosoft.vsm.model.Executor.FSMEvents.FINAL_STATE.getName())
                    .withSource(childFSMState)
                    .withTarget(s2)
                    .build();

            Transition s2_s3 = Transition.newBuilder()
                    .withTrigger(eu.mihosoft.vsm.model.Executor.FSMEvents.STATE_DONE.getName())
                    .withSource(s2)
                    .withTarget(s3)
                    .build();

            FSM fsm = FSM.newBuilder()
                    .withName("FSM")
                    .withInitialState(s1)
                    .withOwnedState(s1, childFSMState, s2, s3)
                    .withFinalState(s3)
                    .withTransitions(s1_childFSMState, childFSMState_s2, s2_s3)
                    .build();

            fsm.vmf().content().stream(State.class).forEach(s -> {
                s.setOnEntryAction(entryAction);
                s.setOnExitAction(exitAction);
            });

            fsm.vmf().content().stream(Transition.class).forEach(t -> {
                t.getActions().add(transitioned);
            });

            fsm.setVerbose(true);

            Executor executor = Executor.newInstance(fsm, MODE);

            fsm.setRunning(true);

            while (executor.hasRemainingEvents()) {
                executor.processRemainingEvents();
            }

            if(MODE == eu.mihosoft.vsm.model.AsyncExecutor.ExecutionMode.PARALLEL_REGIONS) {

                Thread.sleep(100); // TODO (hasRemainingEvents() might still be buggy)

                while (executor.hasRemainingEvents()) {
                    executor.processRemainingEvents();
                }
            }

            fsm.setRunning(false);

            var expectedEvtList = Arrays.asList(
                    "enter s1",           // <- fsm:init

                    "exit s1",            // <- fsm:state-done
                    "transitioning from s1 to ChildFSMState, via event fsm:state-done",
                    "enter ChildFSMState",

                    // FSM1 (Region 1)
                    "enter c1-fsm1",      // <- fsm:init

                    "exit c1-fsm1",       // <- fsm:state-done
                    "transitioning from c1-fsm1 to c2-fsm1, via event fsm:state-done",
                    "enter c2-fsm1",

                    "exit c2-fsm1",       // <- fsm stopped (no event generated)

                    // FSM1 (Region 2)
                    "enter c1-fsm2",      // <- fsm:init

                    "exit c1-fsm2",       // <- fsm:state-done
                    "transitioning from c1-fsm2 to c2-fsm2, via event fsm:state-done",
                    "enter c2-fsm2",

                    "exit c2-fsm2",       // <- fsm stopped (no event generated)
                    "exit ChildFSMState", // <- fsm:final-state (all regions of ChildFSMState reached final state)
                    "transitioning from ChildFSMState to s2, via event fsm:final-state",
                    "enter s2",

                    "exit s2",            // <- fsm:state-done (does not interrupt do-action of s2)
                    "transitioning from s2 to s3, via event fsm:state-done",
                    "enter s3",
                    "exit s3"            // <- fsm stopped (no event generated)
            );

            System.out.println("--------------");

            System.out.println(String.join("\n", actualEvtList));

            System.out.println("-------------- END testChildrenDoneEvent(), iteration: " + i);

            // order of child fsms implementation specific
            // (we only test size (number of state transitions + whether do-actions have been interrupted resp. properly executed) )
            Assert.assertEquals(expectedEvtList.size(), actualEvtList.size());

            Assert.assertTrue("do-action of childFSMState should be" +
                            " interrupted since there is a consuming transition that causes childFSMState to exit (evt: fsm:final-state)",
                    childFSMStateWasInterrupted.get());

            Assert.assertFalse("do-action of s2 should not be" +
                            " interrupted since there is no consuming transition that would cause s2 to exit (evt: fsm:state-done)",
                    s2WasInterrupted.get());

        } // end for i

    }

    @Test(timeout = 10000)
    public void testStateDone() throws InterruptedException {

        List<String> actualEvtList = Collections.synchronizedList(new ArrayList<>());

        StateAction entryAction = (s, e) -> {
            actualEvtList.add("enter " + s.getName());
        };

        StateAction exitAction = (s, e) -> {
            actualEvtList.add("exit " + s.getName());
        };

        TransitionAction transitioned = (t, e) -> {
            actualEvtList.add("transitioning from " + t.getSource().getName()
                    + " to " + t.getTarget().getName() + ", via event " + e.getName());
        };

        State s1 = State.newBuilder()
                .withName("s1")
                .build();
        State s2 = State.newBuilder()
                .withName("s2")
                .build();

        State s3 = State.newBuilder()
                .withName("s3")
                .build();

        Transition s1_s2 = Transition.newBuilder()
                .withTrigger(eu.mihosoft.vsm.model.Executor.FSMEvents.STATE_DONE.getName())
                .withSource(s1)
                .withTarget(s2)
                .build();

        Transition s2_s3 = Transition.newBuilder()
                .withTrigger(eu.mihosoft.vsm.model.Executor.FSMEvents.STATE_DONE.getName())
                .withSource(s2)
                .withTarget(s3)
                .build();

        FSM fsm = FSM.newBuilder()
                .withName("FSM")
                .withInitialState(s1)
                .withOwnedState(s1,s2,s3)
                .withFinalState(s3)
                .withTransitions(s1_s2, s2_s3)
                .build();


        fsm.vmf().content().stream(State.class).forEach(s-> {
            s.setOnEntryAction(entryAction);
            s.setOnExitAction(exitAction);
        });

        fsm.vmf().content().stream(Transition.class).forEach(t-> {
            t.getActions().add(transitioned);
        });

        fsm.setVerbose(true);

        Executor executor = Executor.newInstance(fsm, MODE);

        fsm.setRunning(true);
        while(executor.hasRemainingEvents()) {
            executor.processRemainingEvents();
        }
        fsm.setRunning(false);

        var expectedEvtList = Arrays.asList(
                "enter s1",           // <- fsm:init

                "exit s1",            // <- fsm:state-done
                "transitioning from s1 to s2, via event fsm:state-done",
                "enter s2",

                "exit s2",            // <- fsm:state-done
                "transitioning from s2 to s3, via event fsm:state-done",
                "enter s3",
                "exit s3"            // <- fsm stopped (no event generated)
        );

        System.out.println(String.join("\n", actualEvtList));

        Assert.assertEquals(expectedEvtList, actualEvtList);

    }

    @Test
    public void errorStateTest1() {
        State s1 = State.newBuilder()
                .withName("s1")
                .build();
        State s2 = State.newBuilder()
                .withName("s1")
                .withOnEntryAction((s, e) -> {
                    throw new RuntimeException("Exception in s2");
                })
                .build();

        Transition s1s2 = Transition.newBuilder()
                .withTrigger("myEvent1")
                .withSource(s1)
                .withTarget(s2)
                .build();

        State error = State.newBuilder()
                .withName("ERROR")
                .withOnEntryAction((s, e) -> System.out.println("Error: " + e.getArgs().get(0)))
                .build();

        FSM fsm = FSM.newBuilder()
                .withName("FSM")
                .withInitialState(s1)
                .withOwnedState(s1,s2, error)
                .withErrorState(error)
                .withTransitions(s1s2)
                .build();

        Executor executor = Executor.newInstance(fsm, eu.mihosoft.vsm.model.AsyncExecutor.ExecutionMode.SERIAL_REGIONS);

        fsm.setRunning(true);
        executor.process("myEvent1");
        fsm.setRunning(false);


        Assert.assertEquals(fsm.getErrorState(), fsm.getCurrentState());

    }

    @Test
    public void errorStateNestedFSMTest2() {
        State s1 = State.newBuilder()
                .withName("s1")
                .build();
        State s2 = State.newBuilder()
                .withName("s1")
                .withOnEntryAction((s, e) -> {
                    throw new RuntimeException("Exception in s2");
                })
                .build();

        Transition s1s2 = Transition.newBuilder()
                .withTrigger("myEvent1")
                .withSource(s1)
                .withTarget(s2)
                .build();


        FSM fsmChild = FSM.newBuilder()
                .withName("FSM Child")
                .withInitialState(s1)
                .withOwnedState(s1,s2)
                .withTransitions(s1s2)
                .build();

        State error = State.newBuilder()
                .withName("ERROR")
                .withOnEntryAction((s, e) -> System.out.println("Error: " + e.getArgs().get(0)))
                .build();

        FSMState child = FSMState.newBuilder()
                .withName("Region 1")
                .withFSMs(fsmChild)
                .build();

        FSM fsm = FSM.newBuilder()
                .withName("FSM")
                .withInitialState(child)
                .withOwnedState(child, error)
                .withErrorState(error)
                .build();

        Executor executor = Executor.newInstance(fsm, eu.mihosoft.vsm.model.AsyncExecutor.ExecutionMode.SERIAL_REGIONS);

        fsm.setRunning(true);
        executor.process("myEvent1");
        executor.processRemainingEvents(); // handle exception event
        fsm.setRunning(false);


        Assert.assertEquals(fsm.getErrorState(), fsm.getCurrentState());

    }

    @Test
    public void errorStateNestedFSMTest3() throws InterruptedException, ExecutionException {

        // test whether errors are processed in parent fsms if no error state has been registered
        // in the nested fsm

        State s1 = State.newBuilder()
                .withName("s1")
                .build();
        State s2 = State.newBuilder()
                .withName("s1")
                .withOnEntryAction((s, e) -> {
                    throw new RuntimeException("Exception in s2");
                })
                .build();

        Transition s1s2 = Transition.newBuilder()
                .withTrigger("myEvent1")
                .withSource(s1)
                .withTarget(s2)
                .build();


        FSM fsmChild = FSM.newBuilder()
                .withName("FSM Child")
                .withInitialState(s1)
                .withOwnedState(s1,s2)
                .withTransitions(s1s2)
                .build();

        State error = State.newBuilder()
                .withName("ERROR")
                .withOnEntryAction((s, e) -> System.out.println("Error: " + e.getArgs().get(0)))
                .build();

        FSMState child = FSMState.newBuilder()
                .withName("Region 1")
                .withFSMs(fsmChild)
                .build();

        FSM fsm = FSM.newBuilder()
                .withName("FSM")
                .withVerbose(true)
                .withInitialState(child)
                .withOwnedState(child)
                .withOwnedState(child, error)
                .withErrorState(error)
                .build();

        Executor executor = Executor.newInstance(fsm, eu.mihosoft.vsm.model.AsyncExecutor.ExecutionMode.SERIAL_REGIONS);

        executor.startAsync();
        Thread.sleep(100);
        executor.trigger("myEvent1");
        Thread.sleep(100);

        Assert.assertEquals(fsm.getErrorState(), fsm.getCurrentState());
        executor.stop();

    }
}
